---
title: "Ripley's K"
author: "Lambda"
date: "7/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(Seurat)
library(spatstat)
library(loomR)
library(rhdf5)
library(ggrepel)
library(raster)
library(foreach)
library(doParallel)
registerDoParallel(20)
theme_set(theme_bw())
```

# Prepare the data
Here I use a subset of the MOp MERFISH data and a subset of osmFISH data. I use a subset for experimentation, and will later worry about scalability and what if the data doesn't fit into memory. Remember that in that MERFISH datasets, just for one mouse, one sample, there are over 17 million transcript spots. Imagine how many there will be with more samples. Also, especially when looking at transcripts as point process, I don't want the faulty assumption that the cells are cylinders, so I'll only use the central z plane (I think it's number 4) for now.

## Load data
### MERFISH
```{r}
load("merfish_mop.RData")
```

```{r}
xmin <- 2250
xmax <- 3750
ymin <- 1000
ymax <- 1500
seg_cells_sub <- seg_cells[[1]] %>% 
  mutate(keep = map2_lgl(boundaryX, boundaryY, ~ {
    all(.x >= xmin & .x <= xmax) & all(.y >= ymin & .y <= ymax)
  }))
```

```{r}
segs_sub <- segs_sl[[1]][seg_cells_sub$keep]
```

```{r}
centroids <- coordinates(segs_sub) %>% 
  as.data.frame()
names(centroids) <- c("X", "Y")
```

```{r}
seg_cells_sub <- seg_cells_sub %>% 
  filter(keep)
txs_sub <- txs_sl2[[1]] %>% 
  semi_join(seg_cells_sub, by = c("cell_id" = "...1"))
```

```{r}
seg_cells_sub <- seg_cells_sub %>% 
  mutate(...1 = format(...1, scientific = FALSE) %>% str_remove_all("\\s"))
txs_sub <- txs_sub %>% 
  mutate(cell_id = format(cell_id, scientific = FALSE) %>% str_remove_all("\\s"))
```

```{r}
centroids$cell <- seg_cells_sub$...1
```

Subset the gene count matrix
```{r}
mat_use <- merfish$mats[[1]][, colnames(merfish$mats[[1]]) %in% seg_cells_sub$...1]
```

### osmFISH
```{r}
osm <- connect("data/osmFISH/osmFISH_SScortex_mouse_all_cells.loom", mode = "r+")
```

Transcript locations
```{r}
(txs_osm_meta <- h5ls("data/osmFISH/mRNA_coords_raw_counting.hdf5"))
```

```{r}
txs_osm <- map_dfr(txs_osm_meta$name, ~ {
  out <- h5read("data/osmFISH/mRNA_coords_raw_counting.hdf5", name = .x)
  rownames(out) <- c("x", "y")
  out <- as.data.frame(t(out))
  out$gene <- .x
  out
})
```

```{r}
osm_genes <- osm$row.attrs$Gene[]
mer_genes <- rownames(merfish$mats[[1]])
genes_use <- intersect(osm_genes, mer_genes)
```

```{r}
txs_osm <- txs_osm %>% 
  separate(gene, into = c("gene", "hyb"), sep = "_") %>% 
  filter(gene %in% genes_use)
```

```{r}
osm$col.attrs
```

```{r}
osm_coords <- tibble(x = osm$col.attrs$X[],
                     y = osm$col.attrs$Y[],
                     cell = osm$col.attrs$CellID[])
```

```{r}
osm$row.attrs
```

```{r}
txs_sub <- txs_sub %>% 
  filter(target_molecule_name %in% genes_use)
```

Cell segmentations for osmFISH
```{r}
segs_osm <- readRDS("data/osmFISH/polyT_seg.rds")
```

```{r}
segs_osm[[1]][1:5,]
```

I think the polyT_seg file is actually all the polyA staining used for the staining. It's probably also a binary mask. I should actually get the outer boundary of this, but it's not the convex hull, for the cells are not necessarily convex. What to do? sp supports this, so I'll do it.

## Tissue owin
### MERFISH
Right now, the coordinates are clockwise and the first entry is repeated
```{r}
seg_cells_use <- seg_cells_sub %>% 
  mutate(boundaryX = map(boundaryX, ~ rev(.x[-length(.x)])),
         boundaryY = map(boundaryY, ~ rev(.x[-length(.x)]))) %>% 
  unnest(cols = c("boundaryX", "boundaryY"))
```

Actually, because I know that the tissue ends at the left edge of the slice, I'll get the left side of the convex hull combined with that rectangle. To do: Use polyA or H&E images to better segment the tissue to get the owin.
```{r}
inds <- rev(chull(seg_cells_use[, c("boundaryX", "boundaryY")]))
tissue_coords <- seg_cells_use[inds, c("boundaryX", "boundaryY")]
```

```{r}
min(tissue_coords$boundaryX[tissue_coords$boundaryY > 1490])
```

```{r}
tissue_coords <- tissue_coords %>% 
  mutate(rn = row_number())
```

```{r}
tissue_coords %>% 
  filter(boundaryY > 1490, near(boundaryX, 2624.07, tol = 0.001))
```

```{r}
min(tissue_coords$boundaryX[tissue_coords$boundaryY < 1050])
```

```{r}
tissue_coords %>% 
  filter(boundaryY < 1050, near(boundaryX, 2589.675, tol = 0.001))
```

```{r}
poly_use <- rbind(tissue_coords[15:30,1:2],
                  data.frame(boundaryX = c(tissue_coords$boundaryX[30], xmax, xmax,
                                           tissue_coords$boundaryX[15]),
                             boundaryY = c(ymin, ymin, ymax, ymax)))
names(poly_use) <- c("x", "y")
```

```{r}
ggplot(poly_use, aes(x, y)) +
  geom_path() +
  geom_point(data = centroids, aes(X, Y))
```

### osmFISH
I also want a 1500 by 500 um subset that includes the top of the cortex. But in the osmFISH data, the unit is pixel, and one pixel is 0.065 um. I will convert it to um now.
```{r}
osm_coords$x <- osm_coords$x * 0.065
osm_coords$y <- osm_coords$y * 0.065
txs_osm$x <- txs_osm$x * 0.065
txs_osm$y <- txs_osm$y * 0.065
```

```{r}
segs_osm <- map(segs_osm, ~ .x * 0.065)
```

```{r}
segs_inspect <- map(segs_osm, ~ .x[1,])
segs_inspect <- do.call(rbind, segs_inspect)
segs_inspect <- as.data.frame(segs_inspect)
names(segs_inspect) <- c("x", "y")
```

```{r}
ggplot(segs_inspect, aes(x, y)) +
  geom_point(size = 0.5) +
  coord_equal()
```

It turns out that the reason why the segmentation coordinates do not match cell centroids is that the tissue is inverted.

How about transcript coordinates?
```{r}
txs_osm[sample(1:nrow(txs_osm), 5000),] %>% 
  ggplot(aes(x, y)) +
  geom_point(size = 0.5) +
  coord_equal()
```

The transcript coordinates match the segmentation coordinates.
```{r}
osm_coords <- map(segs_osm, colMeans)
osm_coords <- do.call(rbind, osm_coords)
osm_coords <- as.data.frame(osm_coords)
names(osm_coords) <- c("x", "y")
osm_coords$cell <- names(segs_osm)
```

```{r}
xmino <- 1000
xmaxo <- 1500
ymino <- 200
ymaxo <- 1700
ggplot(osm_coords, aes(x, y)) +
  geom_point(size = 0.5) +
  coord_equal(xlim = c(xmino, xmaxo), ylim = c(ymino, ymaxo))
```

```{r}
osm_keep <- map_lgl(segs_osm, ~ {
  all(.x[,1] <= xmaxo & .x[,1] >= xmino) & all(.x[,2] <= ymaxo & .x[,2] >= ymino)
})
```

```{r}
sum(osm_keep)
```

```{r}
segs_osm <- segs_osm[osm_keep]
```

I have to convert the binnary masks to polygon. Just remove all internal points. All internal points have surrounding points and is a surrounding point
```{r}
foo <- as.data.frame(segs_osm[[1]])
names(foo) <- c("x", "y")
```

```{r}
shift_coords <- function(df, direction_x, direction_y, unit_shift = 0.065) {
  if (direction_y == "u") {
    df$y <- df$y + unit_shift
  }
  if (direction_y == "d") {
    df$y <- df$y - unit_shift
  }
  if (direction_x == "l") {
    df$x <- df$x - unit_shift
  } 
  if (direction_x == "r") {
    df$x <- df$x + unit_shift
  }
  paste(df$x, df$y, sep = "_")
}
```

```{r}
all_shifts <- cross_df(list(x = c("l", "r", "n"), y = c("u", "d", "n")))
```

```{r}
foo_shifts <- map2(all_shifts$x, all_shifts$y, shift_coords, df = foo)
```

```{r}
foo_internal <- reduce(.x = foo_shifts, .f = intersect)
```

```{r}
foo_str <- paste(foo$x, foo$y, sep = "_")
```

```{r}
foo_boundary <- foo %>% filter(!foo_str %in% foo_internal)
```

Then I need to sort the boundary points so they are counterclockwise. I can compute the theta of the polar coordinate and sort it.
```{r}
foo_cen <- colMeans(foo_boundary)
foo_boundary2 <- foo_boundary %>% 
  mutate(
    x_cen = x - foo_cen[1],
    y_cen = y - foo_cen[2],
    theta = atan(y_cen/x_cen),
         theta = case_when(x_cen < 0 ~ theta + pi,
                           x_cen > 0 & y_cen < 0 ~ theta + 2*pi,
                           TRUE ~ theta)) %>% 
  arrange(theta)
# remove large jumps in x and y
foo_boundary2 <- foo_boundary2 %>% 
  mutate(x_lag = lag(x),
         y_lag = lag(y)) %>% 
  filter(abs(x - x_lag) < 0.065, abs(y - y_lag) < 0.065)
```

```{r}
get_boundary <- function(df, unit_shift = 0.065) {
  all_shifts <- cross_df(list(x = c("l", "r", "n"), y = c("u", "d", "n")))
  shifts <- map2(all_shifts$x, all_shifts$y, shift_coords, df = df)
  internal <- reduce(.x = shifts, .f = intersect)
  df_str <- paste(df$x, df$y, sep = "_")
  boundary <- df %>% filter(!df_str %in% internal)
  cen <- colMeans(boundary)
  boundary <- boundary %>% 
    mutate(
      x_cen = x - cen[1],
      y_cen = y - cen[2],
      theta = atan(y_cen/x_cen),
      theta = case_when(x_cen < 0 ~ theta + pi,
                        x_cen > 0 & y_cen < 0 ~ theta + 2*pi,
                        TRUE ~ theta)) %>% 
    arrange(theta)
  # remove large jumps in x and y
  boundary <- boundary %>% 
    mutate(x_lag = lag(x),
           y_lag = lag(y)) %>% 
    filter(abs(x - x_lag) < unit_shift, abs(y - y_lag) < unit_shift)
  boundary[, c("x", "y")]
}
```

```{r}
ggplot(foo_boundary2, aes(x, y, color = seq_along(x))) +
  geom_point()
```

```{r}
txs_osm_sp <- SpatialPoints(as.matrix(txs_osm[,c("x", "y")]))
```


```{r}
segs_osm <- foreach(i = segs_osm) %dopar% {
  colnames(i) <- c("x", "y")
  out <- get_boundary(as.data.frame(i))
  out
}
names(segs_osm) <- names(osm_keep)[osm_keep]
```

```{r}
makeSP2 <- function(dfl) {
  poly_list <- map(dfl, ~ Polygon(as.matrix(.x[, c("x", "y")]), hole = FALSE))
  poly_list <- map2(poly_list, names(dfl), ~ Polygons(list(.x), ID = .y))
  segs <- SpatialPolygons(poly_list)
  segs
}
```

```{r}
segs_osm <- imap(segs_osm, ~ mutate(.x, cell = .y))
```

```{r}
segs_osm_sp <- map(segs_osm, ~ rbind(.x, .x[1,])) %>% makeSP2()
```

```{r}
tx_osm_ind <- over(txs_osm_sp, segs_osm_sp)
txs_osm$cell <- names(segs_osm)[tx_osm_ind]
```

How many transcripts were not mapped to cells?
```{r}
mean(is.na(tx_osm_ind))
```

What, really?
```{r}
segs_osm <- bind_rows(segs_osm)
```

```{r}
ggplot(segs_osm, aes(y, x)) +
  geom_point(data = txs_osm, size = 0.1, alpha = 0.3) +
  geom_polygon(aes(group = cell), fill = "red", alpha = 0.5) +
  scale_y_continuous(limits = c(xmino, xmaxo)) +
  scale_x_continuous(limits = c(ymino, ymaxo)) +
  coord_equal()
```

So I assigned transcripts to cells (did not work, Linnarsson Lab's fault). How about the tissue owin? The top of the tissue is my concern. Again, for simplicity, I'll just use the convex hull trick as the top is pretty gently curved. I'll just use transcript locations for tissue owin instead. Is it that the transcript coordinates don't match the cell coordinates, or the genes kept are not expressed in those cells that seem not to match?
```{r}
txs_osm <- txs_osm %>% 
  filter(between(x, xmino, xmaxo), between(y, ymino, ymaxo))
osm_coords <- osm_coords %>% 
  filter(between(x, xmino, xmaxo), between(y, ymino, ymaxo))
txs_osm2 <- txs_osm %>% 
  filter(!is.na(cell))
```

```{r}
inds <- rev(chull(segs_osm[, c("x", "y")]))
tissue_coords <- segs_osm[inds, c("x", "y")]
```

```{r}
min(tissue_coords$y[tissue_coords$x > 1450])
```

```{r}
tissue_coords <- tissue_coords %>% 
  mutate(rn = row_number())
```

```{r}
tissue_coords %>% 
  filter(x > 1450, near(y, 211.9, tol = 0.001))
```

```{r}
min(tissue_coords$y[tissue_coords$x < 1050])
```

```{r}
tissue_coords %>% 
  filter(x < 1050, near(y, 283.725, tol = 0.001))
```

```{r}
poly_use <- rbind(tissue_coords[32:36,1:2],
                  data.frame(x = c(xmaxo, xmaxo, xmino, xmino),
                             y = c(tissue_coords$y[36], ymaxo, ymaxo, tissue_coords$y[32])))
```

```{r}
ggplot(poly_use, aes(x, y)) +
  geom_path() +
  geom_point(data = osm_coords) +
  coord_equal()
```


## SMSeurat objects
I find myself using this object even without Seurat. That's why it's even more important to write the getters and setters.
```{r}
mer <- CreateSMSeurat(cell_centroids = centroids, 
                tx_coords = txs_sub[, c("global_x", "global_y", "cell_id",
                                        "target_molecule_name")],
                cell_segmentations = seg_cells_use[, c(2, 3, 1)], 
                tissue_owin = owin(poly = poly_use),
                assay = "RNA", key = "merfish_")
```


```{r}
osm_sm <- CreateSMSeurat()
```

# Seurat
```{r}
seu <- CreateSeuratObject(mat_use)
```

```{r}
seu <- AddMetaData(seu, setNames(seg_cells_sub$slice_id, seg_cells_sub$...1),
                   col.name = "slice")
```

```{r}
seu <- AddImage(seu, mer)
```


```{r}
FeatureScatter(seu, "nCount_RNA", "nFeature_RNA")
```

```{r}
seu <- SCTransform(seu)
```

```{r}
seu <- RunPCA(seu, npcs = 30, verbose = FALSE)
ElbowPlot(seu, ndims = 30)
```

```{r}
seu <- FindNeighbors(seu, dims = 1:30)
seu <- FindClusters(seu, resolution = 0.2)
```

```{r}
PCAPlot(seu)
```

```{r}
SpatialPlot2(seu, group.by = "seurat_clusters")
```

Here comes Ripley's K on the cells; I think it's more about tissue than the technology per se. I'll first experiment with Ripley's K on the cells, and then on transcripts within cells. Just to make a subcellular one for MERFISH and one for osmFISH. 

```{r}
SpatialFeaturePlot2(seu, "Cux2") +
  scale_fill_distiller(palette = "Blues", direction = 1)
```

# Trying out spatstat
To do: Getters and setters of slotes within SpatialImage that operates from the Seurat object

## Cell level
```{r}
ggplot(centroids, aes(X, Y)) +
  geom_hex(binwidth = 70) +
  coord_equal()
```

```{r}
ggplot(centroids, aes(X, Y)) +
  geom_density2d_filled() +
  coord_equal()
```

```{r}
foo <- ppp(x = centroids$X, y = centroids$Y, window = owin(poly = poly_use))
```

```{r}
H <- hextess(foo, 50)
hQ <- quadratcount(foo, tess = H)
quadrat.test(hQ)
```

Quadrat test suggests that the cells are pretty homogeneously distributed in space.

```{r}
fp <- frypoints(foo)
```

```{r}
fp_coords <- coords(fp)
```

```{r}
ggplot(fp_coords, aes(x, y)) +
  geom_hex(binwidth = 50) +
  coord_equal() +
  scale_fill_viridis_c()
```

So the Fry plot suggests clustering compared to CRS. Really? To be honest, I expected regularity due to the finite size of the cells. But judging from the size and shape of that single peak, it looks like edge effect, so it's probably still pretty close to CSR. I'll see that in the K function, which also shows regularity and clustering over different length scales. 
```{r}
K <- Kest(foo)
plot(K)
```

```{r}
plot(envelope(foo))
```

```{r}
L <- Lest(foo)
plot(L)
```

At r > about 50, the different border corrections disagree with each other whether the point process is regular or clustered.
```{r}
plot(envelope(foo, Lest, global = TRUE))
```

So the cells are a tiny bit regular at a radius between 0 (or the cell size) and up to about 20 um, which means about the size of a Visium spot. I suppose that's just due to the physical size of cells plus some extra space say for dendrites that are missed by the segmentation. I wonder if this will be different in other tissues. Actually I don't expect the K function to be all that useful at the tissue level beccause while K function assumes that the point process is stationary, distribution of cells in tissues is often not (well, there's Kinhom anyway). But cross type K function can be more useful, which I'll incorporate into Voyager later, in a larger dataset I analyze in more depth rather than this small subset used for experimentation. 
```{r}
g <- pcf(foo, divisor = "d")
plot(g)
```

This is consistent with the K and L functions. One thing: there's a little peak at 10. Shall I take the peak seriously? I think it's about cell size.

## Transcript level
Anyway, I don't think putting the cell coordinates in Seurat makes these explorations any more convenient, since we have to load the coordinates first anyway. But I do think this will make it easier for subcellular transcript localization, since it tooks a bit of work to convert whatever loaded into ppp's and a bit of work to get it and estimate those summary functions for many cells.

### Intensity
Basically, assuming homogeneity, the number of points per unit area or volume. The section is 10 um thick, with 7 1.5 um z planes. Since I don't have a different x-y segmentation for each z plane, the cells are assumed to be cylinders, so this is a caveat. Then what I have here is sort of in between slide-seq and true single cell. If I were to really analyze this dataset more carefully, I will demand the 3D segmentation, or if infeasible, try to account for the possible mixture of cells in those cylinders.

How is the area of the cell distributed?
```{r}
areas <- map_dbl(mer@spots, area)
```

```{r}
hist(areas, breaks = 50)
```

```{r}
intensities <- map_dbl(mer@spots, intensity)
hist(intensities, breaks = 50)
```

I suppose for this sort of data, I should automatically compute area and intensity to metadata once AddImage is called just like how nCount and nFeature are added once the Seurat object is initialized. The 2020 MOp MERFISH paper used the same preprocessing used in the 2018 hypothalamus paper, which removed cells with volume < 100 um^3, which means here the area is less than 10 when I assume cylinders.

```{r}
ntx <- map_int(mer@spots, npoints)
hist(ntx, breaks = 50)
```

```{r}
summary(ntx)
```

```{r}
mer <- mer[Cells(mer)[areas > 10 & ntx > 10]]
```

How does number of transcripts relate to cell size?
```{r}
df <- tibble(nCount = seu$nCount_RNA,
             area = areas,
             intensity = intensities) %>% 
  filter(areas > 10)
```

```{r}
ggplot(df, aes(area, nCount)) +
  geom_hex(bins = 30) +
  scale_fill_distiller(palette = "Blues", direction = 1) +
  geom_smooth(method = "lm")
```

Here number of transcripts does not seem to scale with cell size. Again, cells are not cylinders and cell types are lumped together. How about I look at a specific gene?
```{r}
df$Cux2 <- as.vector(GetAssayData(seu, slot = "counts")["Cux2",])[areas > 10]
```

```{r}
ggplot(df, aes(area, Cux2)) +
  geom_hex(bins = 50) +
  scale_fill_distiller(palette = "Blues", direction = 1) +
  geom_smooth(method = "lm")
```

I suppose this depends on cell type, and the cells that do highly express this gene still have typical size, though the really high ones tend to be larger. 

```{r}
# Use ggplot2
my_plot_ppp <- function(x, mark = FALSE, plot = c("point", "hex"), ...) {
  plot <- match.arg(plot)
  xy <- coords(x)
  if (mark && plot == "point") {
    xy$mark <- marks(x)
  }
  seg <- as.data.frame(Window(x))
  seg <- rbind(seg, seg[1,])
  p <- ggplot(xy, aes(x, y)) +
    geom_path(data = seg) +
    coord_equal()
  if (plot == "hex") {
    p <- p + 
      geom_hex(...)
  } else {
    if (!mark) {
    p <- p + 
      geom_point(size = 0.5, alpha = 0.5)
    } else {
      # For now the only mark I have is gene
      p <- p + 
        geom_point(aes(color = mark), size = 0.5)
    }
  }
    p
}
```

```{r}
my_plot_ppp(mer@spots[[4]], plot = "point")
```

It does seem that upon inspection, I can tell where the nucleus might be though I don't have nuclei segmentation info; in some cells, transcripts tend to cluster in the nucleus, while in some cells, transcripts tend to be in the cytosol, though some cells seem more homogeneous. Again, this is not transcriptome wide, so if I were to seriously analyze this, I should work on `cosmodrome` first and see if I can make it faster and more user friendlier than merlin and starfish; I can't always count on the data the authors make available.

### K and L functions
Now I'll see what if I estimate K and L functions for each cell. I do expect to see some clustering, as an artefact of the fact that the point process is not homogeneous. I can use the inhomogeneous K function that accounts for local intensity. But is it intensity or actual clustering? There's no way to tell here. Is it correlation-stationary, i.e. correlation only depends on distance? Maybe. Perhaps this is a more helpful assumption in many cases, but I don't it still applies when that nucleus is in the way; I would rather fit a Strauss process or cluster process and compare that model to a Poisson one instead, and add other covariates like location of cell in tissue, distance of transcript to nucleus, to cell membrane, neighboring cell types, and etc. That indeed is of great interest; I definitely should spend a lot of time on that after I'm done with, em, so many things, like the museumst paper and Shashank's paper. But here I just want some sort of comparison with osmFISH data and to get more familiar with spatstat.
```{r}
foo <- mer@spots[[4]]
```

```{r}
L <- Lest(foo, correction = "iso")
plot(L)
```

```{r}
env <- envelope(foo, Lest, global = TRUE)
plot(env)
```

I'll plot all the L functions together on a ggplot

```{r}
names(mer@spots) <- Cells(mer)
Ls <- map(mer@spots, Lest, correction = "iso")
Ls_df <- imap_dfr(Ls, ~ {
  out <- as.data.frame(.x)
  out$cell <- .y
  out
})
```

```{r}
ggplot(Ls_df) +
  geom_line(aes(r, iso, group = cell), alpha = 0.2, size = 0.5, color = "blue") +
  geom_density_2d(aes(r, iso), color = "cornflowerblue") +
  scale_fill_viridis_d() +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  coord_equal() +
  theme(legend.position = "none") +
  labs(x = "r", y = "L(r)")
```

So while when I inspected individual cells, the L function does not significantly deviate from the theoretical value given Poisson, it does seem that in most cells, the transcript spots for all genes measured, at least within this z-plane, are a little clustered at r > 1 um and perhaps a little regular at r < 1 um. A few cells are much more clustered. Is this significant? I don't know.

```{r}
L_pooled <- do.call(pool, Ls)
```

```{r}
plot(L_pooled, cbind(pooliso, pooltheo) ~ r,
     shade=c("loiso", "hiiso"),
     main="Pooled L function of transcripts in cells")
```

Anyway, nothing surprising. It was said that the physical size of each transcript spot is 100 nm, or 0.1 um, so the regularity seen here is just the physical size of the spots (for 1 z stack. See, that's why don't do the cylinder trick, but I have to do it here because the osmFISH dataset doesn't have any z info so I have no choice but do it). Then the pooled L function rises above the theoretical line at r > 0.3, for whatever reason, whether inhomogeneity like the stuff RNA velocity relies on or some biological process that lead to clustering.

```{r}
saveRDS(mer, "mer_SMSeurat.rds")
```

