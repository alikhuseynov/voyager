---
title: "Untitled"
author: "Lambda"
date: "7/22/2020"
output: html_document
---

Here I get the genes shared by mouse brain (I tried to get cortex but not always available for given technologies) across a number of spatial transcriptomics technologies, and compare:

1. Total counts of the shared genes (only for brain data, especially when it comes to marker genes) per cell
2. For non-brain data as well, number of UMI/spots per gene in each cell/spot (eh, "spot" has been used in two very different senses in this sentence)
3. If I still have time after Ripley's K and related S4 methods, then look at the distribution and whether gene counts have more zeros than expected after accounting for cell types. This will be the beginning of the next paper.

```{r}
library(tidyverse)
library(Seurat)
library(SeuratData)
library(Matrix)
library(ggforce)
library(readxl)
library(vroom)
library(sp)
library(foreach)
library(doParallel)
library(loomR)
registerDoParallel(40)
theme_set(theme_bw())
```

# Loading data

## STARmap
```{r}
# Starmap visual cortex and medial prefrontal cortex
read_starmap_mat <- function(d) {
  d <- normalizePath(d, mustWork = TRUE)
  m <- read_csv(paste0(d, "/cell_barcode_count.csv"), col_names = FALSE)
  g <- read_csv(paste0(d, "/cell_barcode_names.csv"), col_names = c("index", "code", "gene"))
  m <- t(as.matrix(m))
  rownames(m) <- g$gene
  as(m, "dgCMatrix")
}
```

```{r}
(starmap_dirs <- list.dirs("data/2018_Wang_STARmap/combinatorially_encoded/", 
                           recursive = TRUE))
```

```{r}
starmap <- tibble(method = "STARmap",
                  species = "mouse",
                  tissue = c(rep("mpfc", 4), rep("visual", 6)),
                  directory = starmap_dirs[c(3:6, 8, 9, 11:14)],
                  experiment = basename(directory))
```

```{r}
starmap <- starmap %>% 
  mutate(mats = map(directory, read_starmap_mat))
```

## ExM-MERFISH
```{r}
exm_merfish <- tibble(method = "ExM-MERFISH",
                      species = "human",
                      tissue = "U-2 OS",
                      directory = "data/2019_subcellular_ExM-MERFISH/whole_cell.csv",
                      experiment = basename(directory))
```

```{r}
exm_merfish_mat <- read_csv(exm_merfish$directory)
exm_merfish_genes <- exm_merfish_mat$X1
exm_merfish_mat <- as.matrix(exm_merfish_mat[, -1])
rownames(exm_merfish_mat) <- exm_merfish_genes
exm_merfish_mat <- as(exm_merfish_mat, "dgCMatrix")
exm_merfish$mats <- list(exm_merfish_mat)
rm(exm_merfish_mat)
```

## HCR-seqFISH
From the 2016 Sheel Shah paper
```{r}
hcr_seqfish <- tibble(method = "HCR-seqFISH",
                      species = "mouse",
                      tissue = c("hippo", "hippo", "hippo surround", "cortex", "hippo"),
                      directory = paste0("data/2016_Shah_HCR-seqFISH/",
                                         c(rep("expression125.xlsx", 4),
                                         "expression249.xlsx")),
                      experiment = c("brain1", "brain2_hippo", "brain2_hippo_surround",
                                     "brain2_cortex", "hippo249"))
```

```{r}
brain1 <- read_xlsx(hcr_seqfish$directory[1], sheet = 1)
brain1 <- brain1[, -1]
brain1 <- as(t(as.matrix(brain1)), "dgCMatrix")
```

```{r}
sheet_use <- c(2:4, 1)
```

```{r}
foo <- read_xlsx(hcr_seqfish$directory[2], sheet = 2, col_names = FALSE)
```

```{r}
# For the rest of the sheets
read_shah_hcr <- function(d, s) {
  m <- read_xlsx(d, sheet = s, col_names = FALSE)
  g <- m$...1
  g <- str_remove_all(g, "'")
  m <- m[, -1]
  m <- as(as.matrix(m), "dgCMatrix")
  rownames(m) <- g
  m
}
```

```{r}
hcr_seqfish <- hcr_seqfish %>% 
  mutate(mats = c(brain1,
                  map2(directory[-1], sheet_use, read_shah_hcr)))
```

## MERFISH 
From the 2020 primary motor cortex study. The counts matrix in AnnData is already normalized; I want the raw counts, as for the most part I'm comparing similar cell types, mostly in mice, so I don't expect different cell sizes to play a huge role. Though after this presentation and perhaps after Sha's paper, I really need to look into this, and also cell shapes and subcellular distribution of transcripts.

Here I'll use one sample for now. The transcript locations are given, but not assigned to cells; I need to use the cell segmentation polygons (I think it's really just the cell bodies when it comes to neurons, but I wonder what happens to dendritic transcripts, which are different from those in the cell body). But while transcript locations are given in 3 dimentions (though only 7 z planes), the cell segmentations only have x and y. The units are microns, and the sections are 10 um thick, so it's probably not too bad to assume cells to be oddly shaped cylinders.

```{r}
seg_cells <- vroom("data/merfish_mop/segmented_cells_mouse1sample1.csv", 
                   delim = ",")
seg_cells <- as_tibble(seg_cells)
```

```{r}
seg_cells <- seg_cells %>% 
  mutate(boundaryX = map(boundaryX, ~ as.numeric(str_split(.x, ", ")[[1]])),
         boundaryY = map(boundaryY, ~ as.numeric(str_split(.x, ", ")[[1]])))
```

```{r}
all.equal(lengths(seg_cells$boundaryX), lengths(seg_cells$boundaryY))
```

Also make sure that the start point and end point are the same for the polygons as sp requires this.
```{r}
seg_cells <- seg_cells %>% 
  mutate(boundaryX = map(boundaryX, ~ c(.x, .x[1])),
         boundaryY = map(boundaryY, ~ c(.x, .x[1])))
```

```{r}
summary(lengths(seg_cells$boundaryX))
```

Since I added the first coordinate to the back, here 2 means just 1 point, so I'll get rid of any "cells" with fewer than 4 coordinates
```{r}
seg_cells <- seg_cells %>% 
  filter(lengths(boundaryX) >= 4)
```

Split by slice, to ease parallelization
```{r}
seg_cells <- seg_cells %>% 
  group_split(slice_id)
```

I think I understand why it's so much work to convert vectors of coordinates of boundaries to SpatialPolygons; this is because in geospatial data, regions defined by governments may have holes (think Rome when Vatican is taken out) or have discontiguous parts (think Alaska and Hawaii). But I don't care about that here since cells don't work that way anyway (unless you want to take out say nuclei or organelles or have dendrites separated from cell bodies). So this function
```{r}
makeSP <- function(df) {
  poly_list <- map2(df$boundaryX, df$boundaryY, 
                  ~ Polygon(cbind(.x, .y), hole = FALSE))
  poly_list <- map2(poly_list, df$...1, ~ Polygons(list(.x), ID = .y))
  segs <- SpatialPolygons(poly_list)
  segs
}
```

```{r}
segs_sl <- map(seg_cells, makeSP)
```

```{r}
txs <- vroom("data/merfish_mop/spots_mouse1sample1.csv", delim = ",")
```

Here I'll also split by slice. It's a waste of time to check if a spot in the territory of one slice is in another, distant slice.
```{r}
bbs <- map(segs_sl, bbox)
```

```{r}
txs_sl <- map(bbs, ~ {
  txs_inds <- txs$global_x >= .x["x", "min"] & txs$global_x <= .x["x", "max"] &
    txs$global_y >= .x["y", "min"] & txs$global_y <= .x["y", "max"]
  txs[txs_inds,]
})
```

Now assign points to cells. I still wonder what if a substantial portion are not assigned. 
```{r}
slices <- map_chr(seg_cells, ~ unique(.x$slice_id))
cell_assignment <- vector(mode = "list", length = length(slices))
chunk_size <- 1e5
for (s in seq_along(segs_sl)) {
  cat("Processing", slices[s], "\n")
  txs_use <- SpatialPoints(txs_sl[[s]][, c("global_x", "global_y")])
  segs_use <- segs_sl[[s]]
  bks1 <- seq(1, length(txs_use), by = chunk_size)
  bks <- list(bks1, lead(bks1) - 1)
  bks[[2]][is.na(bks[[2]])] <- length(txs_use)
  bks <- transpose(bks)
  cell_assignment[[s]] <- foreach(i = bks, .combine = c) %dopar% {
    inds <- seq.int(i[[1]], i[[2]], by = 1)
    over(txs_use[inds], segs_use)
  }
}
```

```{r}
txs_sl <- map2(txs_sl, cell_assignment, ~ {
  .x$cell <- unname(.y)
  .x
})
```

Just curious, for each slice, what proportion of spots do not fall into segmented cells?

```{r}
map(cell_assignment, ~ mean(is.na(.x)))
```

Really? Then I wonder if I did something wrong or if not, then what those spots not assigned to any cells are. Does that depend on z plane?
```{r}
map(txs_sl, ~ .x %>% group_by(global_z) %>% summarize(prop_out = mean(is.na(cell))))
```

It seems that z = 0 has higher proportion of spots outside cells. Are there genes that are more likely to have spots outside cells?
```{r}
map(txs_sl, ~ .x %>% group_by(target_molecule_name) %>% 
      summarize(prop_out = mean(is.na(cell))) %>% 
      top_n(10, prop_out))
```

I still wonder why; there are no unannotated garbage here. Would those be transcripts that are not in the cell body and thus missed by segmentation?

```{r}
seg_cells[[1]] %>% 
  unnest(cols = c("boundaryX", "boundaryY")) %>% 
  ggplot(aes(boundaryX, boundaryY, group = ...1)) +
  geom_path() +
  coord_equal()
```

Justs to inspect a patch of this slice
```{r}
xmin <- 2750
xmax <- 3000
ymin <- 1250
ymax <- 1500
foo <- seg_cells[[1]] %>% 
  unnest(cols = c("boundaryX", "boundaryY")) %>% 
  filter(between(boundaryX, xmin, xmax), between(boundaryY, ymin, ymax))
bar <- txs_sl[[1]] %>% 
  filter(between(global_x, xmin, xmax), between(global_y, ymin, ymax))
```

```{r}
ggplot() +
  geom_polygon(data = foo, aes(boundaryX, boundaryY, group = ...1),
               alpha = 0.3, fill = "red") +
  geom_point(data = bar, aes(global_x, global_y), 
             size = 0.1, alpha = 0.3) +
  coord_equal() +
  facet_wrap(~ global_z)
```

Ah, I see. Some of that clearly looks like background. But some of them clearly look like cells but missed by the segmentation, probably because the segmentation boundary only has x and y and the other "cells" are in the z plane that has the provided x and y boundaries (I wonder why they don't provide the z plane of the segmentation while thtey said they did make 3D segmentation in the 2018 hypothalamus paper). But still, I can see some cells missed by segmentation that are present in all z planes. Were they rejected for some other reason? Also, there seems to be more spots at boundaries between FOVs. OK, I've got a LOT of work to do for `cosmodrome`. I've also got a LOT of work to do for `Voyager` to adapt the spatial EDA functions to 3D, plus the debate of the status of the z plane, since the z plane has different quality from x and y. Should z be a mark or a dimension? But cell segmentation just is challenging. Now also check the z plane. Also, it seems that the FOV boundary artefact is more prominent in lower z planes and that it's easier to make out the cells in the highest one.

Anyway, for now, I'll simply use the transcripts that fall inside cells
```{r}
txs_sl2 <- map2(txs_sl, seg_cells, ~ filter(.x, !is.na(cell)) %>% 
                 mutate(cell_id = .y$...1[cell]))
```

```{r}
merfish <- tibble(method = "MERFISH",
                  species = "mouse",
                  tissue = "MOp",
                  directory = "data/merfish_mop/counts.h5ad",
                  experiment = slices)
```

```{r}
merfish <- merfish %>% 
  mutate(mats = map(txs_sl2, ~ {
    m <- .x %>% 
      select(target_molecule_name, cell_id, cell) %>% 
      dplyr::count(target_molecule_name, cell_id, cell)
    gene_ids <- tibble(target_molecule_name = sort(unique(.x$target_molecule_name)),
                       gene_ind = seq_along(target_molecule_name))
    cell_ids <- tibble(cell_id = unique(m$cell_id),
                       cell_ind = seq_along(cell_id))
    m <- m %>% 
      left_join(gene_ids, by = "target_molecule_name") %>% 
      left_join(cell_ids, by = "cell_id")
    sparseMatrix(i = m$gene_ind, j = m$cell_ind, x = m$n, 
                 dimnames = list(gene_ids$target_molecule_name, 
                                 format(cell_ids$cell_id, scientific = FALSE) %>% 
                                   str_remove_all("\\s")))
  }))
```

FINALLY!
```{r}
map(merfish$mats, dim)
```

```{r}
# save the results
save(merfish, seg_cells, segs_sl, txs_sl, txs_sl2, file = "merfish_mop.RData")
```

## osmFISH
This one is easy
```{r}
osm <- connect("data/osmFISH/osmFISH_SScortex_mouse_all_cells.loom", mode = "r+")
```

```{r}
osm
```

```{r}
osmfish <- tibble(method = "osmFISH",
                  species = "mouse",
                  tissue = "ss cortex",
                  directory = "data/osmFISH/osmFISH_SScortex_mouse_all_cells.loom",
                  experiment = "osmFISH_sscortex")
```

```{r}
m <- osm$matrix[,]
m <- t(m)
colnames(m) <- osm$col.attrs$CellID[]
rownames(m) <- osm$row.attrs$Gene[]
m <- as(m, "dgCMatrix")
```

```{r}
osmfish$mats <- list(m)
rm(m)
```

## seqFISH+
```{r}
sf_plus <- vroom("data/seqfish_plus/cortex_svz_counts.csv")
```

```{r}
seqfish_plus <- tibble(method = "seqFISH+",
                       species = "mouse",
                       tissue = "SVZ",
                       directory = "data/seqfish_plus/cortex_svz_counts.csv",
                       experiment = "seqfish+_svz")
```

```{r}
seqfish_plus$mats <- list(t(as.matrix(sf_plus)) %>% as("dgCMatrix"))
```

I'll worry about the subcellular stuff later.

## ST Molecular Atlas
There are over 30,000 spots; I suppose I can feel free to get primary visual cortex, somatosensory cortex, or motor cortex. I think it's also cool that they used ABA anatomical ontology. I think this is one place we should learn from the prequel era. I wonder how the Human Cell Atlas's spatial part goes.
```{r}
st_meta <- read_tsv("data/ST_mol_atlas/meta_table.tsv")
```

```{r}
st_meta <- st_meta %>% 
  filter(ABA_parent %in% c("Isocortex", "Hippocampal region"))
st_meta %>% 
  count(ABA_parent, ABA_name)
```

I still wonder why many studies share their obviously sparse gene count matrices as tsv or csv rather than mtx, wasting so much space.
```{r}
st_mat <- vroom("data/ST_mol_atlas/expr_raw_counts_table.tsv")
```

Which tissues do I already have here? Primary visual cortex, motor cortex, somatosensory cortex, hippocampus, and SVZ. I think the nice thing here is that I can find the corresponding tissues in this ST molecular atlas.

```{r}
st_mat <- st_mat %>% 
  filter(...1 %in% st_meta$X1[st_meta$passed_QC])
st_cell_id <- st_mat$...1
st_mat$...1 <- NULL
st_mat <- t(as.matrix(st_mat)) %>% as("dgCMatrix")
colnames(st_mat) <- st_cell_id
```

```{r}
st_mol_atlas <- tibble(method = "ST",
                       species = "mouse",
                       tissue = c("Isocortex", "Hippocampal region"),
                       directory = "data/ST_mol_atlas/expr_raw_counts_table.tsv",
                       experiment = c("ST_isocortex", "ST_hippo"),
                       mats = list(st_mat[,st_meta$X1[st_meta$ABA_parent == "Isocortex" & st_meta$passed_QC]],
                          st_mat[,st_meta$X1[st_meta$ABA_parent == "Hippocampal region" & st_meta$passed_QC]]))
```

## Slide-seq v2
I don't think the slide-seq v2 paper points to where the data is stored, so I wonder how Seurat team got the data. Anyway, I'm using the hippocampus one provided by Seurat.

```{r}
slide.seq <- LoadData("ssHippo")
```

I don't like the way Seurat's violin plots look. Here's a more aesthetically pleasant version
```{r}
slide.seq@meta.data %>% 
  select(nCount_Spatial, nFeature_Spatial) %>% 
  pivot_longer(cols = c("nCount_Spatial", "nFeature_Spatial"), 
               names_to = "variable", values_to = "value") %>% 
  ggplot(aes(variable, value)) +
  geom_violin() +
  geom_boxplot(width = 0.5) +
  scale_y_log10() +
  annotation_logticks(sides = "l")
```

```{r}
slide_seq <- tibble(method = "slide-seq v2",
                    species = "mouse",
                    tissue = "hippo",
                    directory = NA,
                    experiment = "slide-seq2_hippo",
                    mats = list(GetAssayData(slide.seq, slot = "counts")))
rm(slide.seq)
```

## Visium
None of the published data is from mouse brain, but 10x itself provides Visium data from the brain. 
```{r}
brain <- LoadData("stxBrain", type = "anterior1")
```

```{r}
brain
```

```{r}
names(brain@meta.data)
```

```{r}
brain@meta.data %>% 
  select(nCount_Spatial, nFeature_Spatial) %>% 
  pivot_longer(cols = c("nCount_Spatial", "nFeature_Spatial"), 
               names_to = "variable", values_to = "value") %>% 
  ggplot(aes(variable, value)) +
  geom_violin() +
  geom_jitter(size = 0.1, alpha = 0.1)
  #geom_boxplot(width = 0.5) #+
  #scale_y_log10() +
  #annotation_logticks(sides = "l")
```

```{r}
visium <- tibble(method = "Visium",
                 species = "mouse",
                 tissue = "brain",
                 directory = NA,
                 experiment = "visium_brain",
                 mats = list(GetAssayData(brain, slot = "counts")))
rm(brain) 
```

## Linnarsson scRNA-seq
It's from the old molecular atlas of the mouse brain.
```{r}
linnarsson_ctx <- connect("data/linnarsson_ctx/l1_cortex1.loom", mode = "r+")
```

```{r}
sc <- tibble(method = "10xv1",
             species = "mouse",
             tissue = "cortex",
             directory = "data/linnarsson_ctx/l1_cortex1.loom",
             experiment = "scRNA-seq_cortex")
```

```{r}
m <- linnarsson_ctx$matrix[,]
m <- t(m)
colnames(m) <- linnarsson_ctx$col.attrs$CellID[]
rownames(m) <- linnarsson_ctx$row.attrs$Gene[]
m <- as(m, "dgCMatrix")
```

```{r}
sc$mats <- list(m)
rm(m)
```

# Get relevant matrix summaries
Finally! That really took a while, especially the MERFISH part. Now it's time to do the following:

1. Get the genes shared by all these matrices
2. Compare total counts per cell/spot for those shared genes
3. Compare mean and median counts per cell for those genes

Problem: The datasets that are not transcriptome wide don't have one shared set of genes. What to do? How do I compare them? I can make one plot for the genome wide datasets, and another plot comparing the genome wide datasets with a non-genome wide one with the shared genes

```{r}
tx_wide <- rbind(sc, seqfish_plus, slide_seq, st_mol_atlas, visium)
```

```{r}
shared_genes <- map(tx_wide$mats, ~ rownames(.x) %>% tolower()) %>% 
  reduce(intersect)
length(shared_genes)
```

```{r}
tx_wide <- tx_wide %>% 
  mutate(mats = map(mats, ~ {
    rownames(.x) <- tolower(rownames(.x))
    .x[shared_genes,]
  }))
```

```{r}
tx_wide_n_counts <- tx_wide %>% 
  mutate(nCounts_RNA = map(mats, colSums),
         cell_id = map(mats, colnames),
         zeros = map(mats, ~ colMeans(.x < 1))) %>% 
  select(-mats) %>% 
  unnest(cols = c("nCounts_RNA", "cell_id", "zeros"))
```

For ST, I'll normalize the counts per spot by the number of nuclei in the spot; it's so nice of the Molecular Atlas authors to provide this information.
```{r}
st_meta %>% 
  filter(passed_QC, ABA_parent %in% c("Isocortex", "Hippocampal region")) %>% 
  ggplot(aes(nuclei_segmented)) +
  geom_histogram(bins = 20)
```

```{r}
st_meta %>% 
  filter(passed_QC, ABA_parent %in% c("Isocortex", "Hippocampal region")) %>% 
  pull(nuclei_segmented) %>% 
  summary()
```

Burning question: How about the Visium dataset? OK, some street fighting math: ST's spot diameter is 100 um, though in ths Molecular Atlas, the diameter is actually more than that.

```{r}
hist(st_meta$spot_radius)
```

```{r}
summary(st_meta$spot_radius)
```

Say in practice the diameter is 145 um. Visium's spot diameter is 55 um, but it's hexagonal. How many times are ST spots larger than Visium spots?

```{r}
(pi * 72.5^2)/(22.5^2 * sqrt(3)/2 * 3)
```

So it's about 12.5 times. Then say the ST spot contains 7 nuclei on average, then would it be that on average, one Visium spot contains 1 or fewer nuclei? Well, it was said that a neuron is about 10 um in width. But as seem from the MERFISH plot, a 50 x 50 um square can contain from 1 to like 6 cells, so 10x website's claim that one Visium spot can contain between 1 and 10 cells is reasonable. So I'm back to where I began. I don't know what to do. But I've got data from MERFISH, from which I can get an empirical estimate. OK, cell density actually depends on tissue, and in the motor cortex, part of the tissue; I picked an area that has intermediate density of cells

```{r}
xmin <- 3000
xmax <- 3500
ymin <- 1000
ymax <- 1500
foo <- seg_cells[[1]] %>% 
  unnest(cols = c("boundaryX", "boundaryY")) %>% 
  filter(between(boundaryX, xmin, xmax), between(boundaryY, ymin, ymax))
bar <- txs_sl[[1]] %>% 
  filter(between(global_x, xmin, xmax), between(global_y, ymin, ymax))
```

The diameter is different from the side length. 
```{r}
width_use <- 55*(sqrt(3)/2)
ggplot() +
  geom_hex(data = bar, aes(global_x, global_y), binwidth = width_use) +
  geom_polygon(data = foo, aes(boundaryX, boundaryY, group = ...1),
               alpha = 0.5, fill = "red") +
  coord_equal() +
  scale_x_continuous(expand = expansion()) +
  scale_y_continuous(expand = expansion())
```

It seems that (I mean, by visual inspection) most spots have 2 to 4 cells, so I'll use 3 to normalize the Visium data.

```{r}
tx_wide_n_counts <- tx_wide_n_counts %>% 
  left_join(st_meta[, c("X1", "nuclei_segmented")], by = c("cell_id" = "X1")) %>% 
  filter(nuclei_segmented > 0 | is.na(nuclei_segmented)) %>% 
  mutate(
    nCounts_RNA_norm = case_when(
      is.na(nuclei_segmented) & method != "Visium" ~ nCounts_RNA,
      method == "Visium" ~ nCounts_RNA / 3,
      TRUE ~ nCounts_RNA/nuclei_segmented
    )
  )
```

```{r}
tx_wide_n_counts <- tx_wide_n_counts %>% 
  mutate(experiment = fct_reorder(experiment, nCounts_RNA_norm))
```

```{r}
tx_wide_n_counts %>% 
  filter(nCounts_RNA > 0) %>% 
  ggplot(aes(experiment, nCounts_RNA_norm)) +
  geom_violin() +
  scale_y_log10(minor_breaks = scales::breaks_log(10)) +
  annotation_logticks(sides = "l") +
  labs(title = "Number of UMI/transcripts per cell for shared genes \namong transcriptome-wide methods", y = "")
```

Yeah, so after normalizing number of cells per spot, ST is comparable to scRNA-seq, Visium is somewhat better, and seqFISH+ is certainly better.

```{r}
tx_wide_n_counts %>% 
  mutate(experiment = fct_reorder(experiment, zeros, .desc = TRUE)) %>% 
  ggplot(aes(experiment, zeros)) +
  geom_violin() +
  labs(title = "Proportion of zeros per cell", y = "")
```

How about mean count of each shared gene per cell (yes, normalized for spots)?
```{r}
tx_wide_gene <- tx_wide
tx_wide_gene$mats[tx_wide_gene$method == "ST"] <- 
  map(tx_wide_gene$mats[tx_wide_gene$method == "ST"], ~ {
    nuclei_seg <- st_meta$nuclei_segmented[match(colnames(.x), st_meta$X1)]
    m <- .x[, nuclei_seg > 0]
    nuclei_seg <- nuclei_seg[nuclei_seg > 0]
    sweep(m, 2, STATS = nuclei_seg, FUN = "/")
  })
tx_wide_gene$mats[tx_wide_gene$method == "Visium"] <- 
  map(tx_wide_gene$mats[tx_wide_gene$method == "Visium"], ~ .x/3)
```

```{r}
tx_wide_gene <- tx_wide_gene %>% 
  mutate(mean_count = map(mats, rowMeans),
         gene = map(mats, rownames)) %>% 
  select(-mats) %>% 
  unnest(cols = c("mean_count", "gene")) %>% 
  mutate(experiment = fct_reorder(experiment, mean_count))
```

```{r}
ggplot(tx_wide_gene, aes(experiment, mean_count)) +
  geom_violin() +
  scale_y_log10() +
  annotation_logticks(sides = "l") +
  labs(title = "Mean gene count per cell in transcriptome-wide methods", y = "")
```

```{r, fig.width=8, fig.height=8}
tx_wide_gene %>% 
  select(experiment, gene, mean_count) %>% 
  mutate(mean_count = log10(mean_count)) %>% 
  pivot_wider(names_from = "experiment", values_from = "mean_count") %>% 
  ggplot() +
  geom_hex(aes(x = .panel_x, y = .panel_y), bins = 50) +
  scale_fill_viridis_c() +
  facet_matrix(rows = vars(`scRNA-seq_cortex`:visium_brain))
```

Also compare the sparsity
```{r}
tx_wide <- tx_wide %>% 
  mutate(sparsity = map_dbl(mats, ~ 1 - mean(.x > 0)))
```

```{r}
tx_wide %>% 
  mutate(experiment = fct_reorder(experiment, sparsity, .desc = TRUE)) %>% 
  ggplot(aes(experiment, sparsity)) +
  geom_col()
```

Then what? I suppose because the seqFISH+ dataset has so many genes, I can compare the other datasets with it one by one, to avoid the scenario when too few or simply 0 genes are shared between datasets. How about this: for each set of shared genes, I'll set the median of seqFISH+ to 1. This way it's easier to compare. 
```{r}
tx_panel_comp <- function(query, ref) {
  df <- rbind(query, ref)
  shared_genes <- map(df$mats, rownames) %>% reduce(intersect)
  df <- df %>% 
    mutate(mats = map(mats, ~ .x[shared_genes,]))
  df_n_counts <- df %>% 
    mutate(nCount_RNA = map(mats, colSums),
           zeros = map(mats, ~ colMeans(.x < 1))) %>% 
    select(-mats) %>% 
    unnest(cols = c("nCount_RNA", "zeros"))
  ref_median <- median(df_n_counts$nCount_RNA[df_n_counts$experiment %in% ref$experiment])
  df_n_counts <- df_n_counts %>% 
    mutate(nCount_RNA_norm = nCount_RNA/ref_median,
           facet = unique(query$method),
           experiment = fct_reorder(experiment, nCount_RNA_norm))
  df_n_counts
}
```

```{r}
panel_n_counts <- map_dfr(list(hcr_seqfish, merfish, osmfish, starmap),
                          tx_panel_comp, ref = seqfish_plus) %>% 
  mutate(facet = fct_reorder2(facet, nCount_RNA_norm, method, 
                              .fun = function(x, y) median(x[y != "seqFISH+"])))
```

```{r, fig.width=7, fig.height=7}
panel_n_counts %>% 
  filter(nCount_RNA_norm > 0) %>% 
  ggplot(aes(nCount_RNA_norm, experiment, fill = method != "seqFISH+")) +
  geom_vline(xintercept = 1) +
  geom_violin(orientation = "y") +
  facet_grid(rows = vars(facet), scales = "free_y", space = "free") +
  theme(legend.position = "none") +
  labs(y = "", x = "Relative number of transcripts per cell",
       subtitle = "Number of transcripts per cell relative to seqFISH+ median of shared genes") +
  scale_x_log10() +
  annotation_logticks(sides = "b")
```

```{r, fig.width=7, fig.height=7}
panel_n_counts %>% 
  ggplot(aes(zeros, experiment, fill = method != "seqFISH+")) +
  geom_violin(orientation = "y") +
  facet_grid(rows = vars(facet), scales = "free_y", space = "free") +
  theme(legend.position = "none") +
  labs(y = "", x = "Proportion of zeros per cell",
       subtitle = "Proportion of zeros in genes shared with seqFISH+")
```

```{r}
tx_panel_genes <- function(query, ref) {
  df <- rbind(query, ref)
  shared_genes <- map(df$mats, rownames) %>% reduce(intersect)
  df <- df %>% 
    mutate(mats = map(mats, ~ .x[shared_genes,]))
  df_genes <- df %>% 
    mutate(mean_count = map(mats, rowMeans),
           gene = map(mats, rownames)) %>% 
    select(-mats) %>% 
    unnest(cols = c("mean_count", "gene")) %>% 
    mutate(facet = unique(query$method),
           experiment = fct_reorder(experiment, mean_count))
  df_genes
}
```

```{r}
panel_genes <- map_dfr(list(hcr_seqfish, merfish, osmfish, starmap),
                          tx_panel_genes, ref = seqfish_plus) %>% 
  mutate(facet = fct_reorder2(facet, mean_count, method, 
                                .fun = function(x, y) median(x[y != "seqFISH+"])))
```

```{r, fig.width=7, fig.height=7.5}
panel_genes %>% 
  #filter(nCount_RNA_norm > 0) %>% 
  ggplot(aes(mean_count, experiment, fill = method != "seqFISH+")) +
  geom_violin(orientation = "y") +
  geom_jitter(size = 0.3, alpha = 0.3) +
  facet_grid(rows = vars(facet), scales = "free_y", space = "free") +
  theme(legend.position = "none") +
  labs(y = "", x = "Mean counts per gene",
       title = "Mean counts of gene among cells",
       subtitle = "Among genes shared with seqFISH+ data as reference") +
  scale_x_log10() +
  annotation_logticks(sides = "b")
```

Also plot each gene as a point. I'll not split by experiment here. Just average over methods, for shared genes.

```{r}
tx_gene_scatter <- function(query, ref) {
  df <- rbind(query, ref)
  shared_genes <- map(df$mats, rownames) %>% reduce(intersect)
  df2 <- df %>% 
    mutate(mats = map(mats, ~ .x[shared_genes,]),
           sums = map(mats, rowSums),
           gene = map(mats, rownames)) %>% 
    select(-mats) %>% 
    unnest(cols = c("sums", "gene")) %>% 
    group_by(method, gene) %>% 
    summarize(sums_method = sum(sums))
  df3 <- df %>% 
    mutate(n_cells = map_int(mats, ncol)) %>% 
    select(-mats) %>% 
    group_by(method) %>% 
    summarize(cells_method = sum(n_cells))
  df2 <- df2 %>% 
    left_join(df3, by = "method") %>% 
    mutate(mean_count = sums_method/cells_method,
           method_nm = case_when(method == "seqFISH+" ~ "r",
                                 TRUE ~ "q")) %>% 
    ungroup() %>% 
    select(method_nm, gene, mean_count) %>% 
    pivot_wider(names_from = "method_nm", values_from = "mean_count")
  df2$facet <- unique(query$method)
  df2
}
```

```{r}
panel_genes2 <- map_dfr(list(hcr_seqfish[hcr_seqfish$experiment == "brain2_cortex",], 
                             merfish, osmfish, starmap),
                          tx_gene_scatter, ref = seqfish_plus) %>% 
  mutate(facet = fct_reorder(facet, q))
```

```{r, fig.width=4, fig.height=6}
ggplot(panel_genes2, aes(r, q)) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  geom_point(alpha = 0.3) +
  facet_wrap(~ facet) +
  scale_x_log10() +
  scale_y_log10() +
  annotation_logticks() +
  coord_equal() +
  labs(x = "seqFISH+",
       y = "Method of interest",
       subtitle = "Mean gene count per cell in\nmethod of interest vs. seqFISH+")
```

