% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/univariate.R
\name{calculateUnivariate}
\alias{calculateUnivariate}
\alias{calculateMoransI}
\alias{calculateUnivariate,ANY-method}
\alias{calculateUnivariate,SpatialFeatureExperiment-method}
\alias{calculateMoransI,ANY-method}
\alias{calculateMoransI,SpatialFeatureExperiment-method}
\alias{colDataUnivariate}
\alias{colDataMoransI}
\alias{colGeometryUnivariate}
\alias{colGeometryMoransI}
\alias{annotGeometryUnivariate}
\alias{annotGeometryMoransI}
\alias{runUnivariate}
\alias{runMoransI}
\title{Univariate spatial stiatistics}
\usage{
\S4method{calculateUnivariate}{ANY}(
  x,
  listw,
  type = c("moran", "geary", "moran.mc", "geary.mc", "moran.test", "geary.test",
    "globalG.test", "sp.correlogram", "moran.plot", "localmoran", "localmoran_perm",
    "localC", "localC_perm", "localG", "localG_perm", "LOSH", "LOSH.mc", "LOSH.cs",
    "gwss"),
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  returnDF = TRUE,
  p.adjust.method = "BH",
  ...
)

\S4method{calculateUnivariate}{SpatialFeatureExperiment}(
  x,
  type,
  features = NULL,
  colGraphName = 1L,
  sample_id = "all",
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  returnDF = TRUE,
  include_self = FALSE,
  p.adjust.method = "BH",
  swap_rownames = NULL,
  ...
)

\S4method{calculateMoransI}{ANY}(x, ..., BPPARAM = SerialParam(), zero.policy = NULL)

\S4method{calculateMoransI}{SpatialFeatureExperiment}(
  x,
  features = NULL,
  colGraphName = 1L,
  sample_id = "all",
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  returnDF = TRUE,
  include_self = FALSE,
  p.adjust.method = "BH",
  swap_rownames = NULL,
  ...
)

colDataUnivariate(
  x,
  type,
  features,
  colGraphName = 1L,
  sample_id = "all",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

colDataMoransI(
  x,
  features,
  colGraphName = 1L,
  sample_id = "all",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

colGeometryUnivariate(
  x,
  type,
  features,
  colGeometryName = 1L,
  colGraphName = 1L,
  sample_id = "all",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

colGeometryMoransI(
  x,
  features,
  colGeometryName = 1L,
  colGraphName = 1L,
  sample_id = "all",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

annotGeometryUnivariate(
  x,
  type,
  features,
  annotGeometryName = 1L,
  annotGraphName = 1L,
  sample_id = "all",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

annotGeometryMoransI(
  x,
  features,
  annotGeometryName = 1L,
  annotGraphName = 1L,
  sample_id = "all",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

runUnivariate(
  x,
  type,
  features = NULL,
  colGraphName = 1L,
  sample_id = "all",
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  swap_rownames = NULL,
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)

runMoransI(
  x,
  features = NULL,
  colGraphName = 1L,
  sample_id = "all",
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  swap_rownames = NULL,
  zero.policy = NULL,
  include_self = FALSE,
  p.adjust.method = "BH",
  ...
)
}
\arguments{
\item{x}{A numeric matrix whose rows are features/genes, or a
\code{SpatialFeatureExperiment} (SFE) object with such a matrix in an
assay.}

\item{listw}{Weighted neighborhood graph as a \code{spdep} \code{listw}
object.}

\item{type}{An integer specifying the index or string specifying the name of
the *Geometry to query or replace. If missing, then the first item in the
*Geometries will be returned or replaced.}

\item{BPPARAM}{A \code{\link{BiocParallelParam}} object specifying whether
and how computing the metric for numerous genes shall be parallelized.}

\item{zero.policy}{default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA}

\item{returnDF}{Logical, when the results are not added to a SFE object,
whether the results should be formatted as a \code{DataFrame}.}

\item{p.adjust.method}{Method to correct for multiple testing, passed to
\code{\link[spdep]{p.adjustSP}}. Methods allowed are in
\code{\link{p.adjust.methods}}.}

\item{...}{Other arguments passed to S4 method (for convenience wrappers like
\code{calculateMoransI}) or method used to compute metrics as specified by
the argument \code{type} (as in more general functions like
\code{calculateUnivariate}). See documentation in the \code{spdep} package
for the latter.}

\item{features}{Genes (\code{calculate*} SFE method and \code{run*}) or
numeric columns of \code{colData(x)} (\code{colData*}) or any
\code{\link{colGeometry}} (\code{colGeometry*}) or
\code{\link{annotGeometry}} (\code{annotGeometry*}) for which the
univariate metric is to be computed. Default to \code{NULL}. When
\code{NULL}, then the metric is computed for all genes with the values in
the assay specified in the argument \code{exprs_values}. This can be
parallelized with the argument \code{BPPARAM}. For genes, if the row names
of the SFE object are Ensembl IDs, then the gene symbol can be used and
converted to IDs behind the scene with a column in \code{rowData} can be
specified in \code{swap_rownames}. However, if one symbol matches multiple
IDs, a warning will be given and the first match will be used. Internally,
the results are always stored by the Ensembl ID rather than symbol.}

\item{colGraphName}{Name of the listw graph in the SFE object that
corresponds to entities represented by columns of the gene count matrix.
Use \code{\link{colGraphNames}} to look up names of the available graphs
for cells/spots. Note that for multiple \code{sample_id}s, it is assumed
that all of them have a graph of this same name.}

\item{sample_id}{Sample(s) in the SFE object whose cells/spots to use. Can be
"all" to compute metric for all samples; the metric is computed separately
for each sample.}

\item{exprs_values}{Integer scalar or string indicating which assay of x
contains the expression values.}

\item{include_self}{Logical, whether the spatial neighborhood graph should
include edges from each location to itself. This is for Getis-Ord Gi* as in
\code{localG} and \code{localG_perm}, not to be used for any other method.}

\item{swap_rownames}{Name of a column in \code{rowData} to identify features
instead of the row names of the SFE object. For example, if the row names
of the SFE object are Ensembl IDs and gene symbols are in the "symbol"
column in \code{rowData}, then putting "symbol" for this argument will use
the gene symbols to identify which gene's local results to get or set.}

\item{colGeometryName}{Name of a \code{colGeometry} \code{sf} data frame
whose numeric columns of interest are to be used to compute the metric. Use
\code{\link{colGeometryNames}} to look up names of the \code{sf} data
frames associated with cells/spots.}

\item{annotGeometryName}{Name of a \code{annotGeometry} \code{sf} data frame
whose numeric columns of interest are to be used to compute the metric. Use
\code{\link{annotGeometryNames}} to look up names of the \code{sf} data
frames associated with annotations.}

\item{annotGraphName}{Name of the listw graph in the SFE object that
corresponds to the \code{annotGeometry} of interest. Use
\code{\link{annotGraphNames}} to look up names of available annotation
graphs.}
}
\value{
In \code{calculateUnivariate}, if \code{returnDF = TRUE}, then a
  \code{DataFrame}, otherwise a list each element of which is the results for
  each feature. For \code{run*}, a \code{SpatialFeatureExperiment} object
  with the results added. See Details for where the results are stored.
}
\description{
These functions compute univariate spatial statistics, both global and local,
on matrices, data frames, and SFE objects. For SFE objects, the statistics
can be computed for numeric columns of \code{colData}, \code{colGeometries},
and \code{annotGeometries}, and the results are stored within the SFE object.
\code{calculateMoransI} and \code{runMoransI} are convenience wrappers for
\code{calculateUnivariate} and \code{runUnivariate} respectively.
}
\details{
Most univariate methods in the package \code{spdep} are supported here. These
methods are global, meaning returning one result for all spatial locations in
the dataset: \code{\link[spdep]{moran}}, \code{\link[spdep]{geary}},
\code{\link[spdep]{moran.mc}}, \code{\link[spdep]{geary.mc}},
\code{\link[spdep]{moran.test}}, \code{\link[spdep]{geary.test}},
\code{\link[spdep]{globalG.test}}, \code{\link[spdep]{sp.correlogram}}.

The following methods are local, meaning each location has its own results:
\code{\link[spdep]{moran.plot}}, \code{\link[spdep]{localmoran}},
\code{\link[spdep]{localmoran_perm}}, \code{\link[spdep]{localC}},
\code{\link[spdep]{localC_perm}}, \code{\link[spdep]{localG}},
\code{\link[spdep]{localG_perm}}, \code{\link[spdep]{LOSH}},
\code{\link[spdep]{LOSH.mc}}, \code{\link[spdep]{LOSH.cs}}. The
\code{GWmodel::gwss} method will be supported soon, but is not supported yet.

Global results for genes are stored in \code{rowData}. For \code{colGeometry}
and \code{annotGeometry}, the results are added to an attribute of the data
frame called \code{featureData}, which is a DataFrame analogous to
\code{rowData} for the gene count matrix. New column names in
\code{featureData} would follow the same rules as in \code{rowData}. For
\code{colData}, the results can be accessed with the \code{colFeatureData}
function.

Local results are stored in the field \code{localResults} field of the SFE
object, which can be accessed with
\code{\link[SpatialFeatureExperiment]{localResults}} or
\code{\link[SpatialFeatureExperiment]{localResult}}. If the results have
p-values, then -log10 p and Benjamin-Hochberg corrected -log10 p are added.
Note that in the multiple testing correction, \code{\link[spdep]{p.adjustSP}}
is used.
}
\examples{
library(SpatialFeatureExperiment)
library(SingleCellExperiment)
library(SFEData)
sfe <- McKellarMuscleData("small")
colGraph(sfe, "visium") <- findVisiumGraph(sfe)
features_use <- rownames(sfe)[1:5]

# Moran's I
moran_results <- calculateMoransI(sfe,
    features = features_use,
    colGraphName = "visium",
    exprs_values = "counts"
)

# This does not advocate for computing Moran's I on raw counts.
# Just an example for function usage.

sfe <- runMoransI(sfe,
    features = features_use, colGraphName = "visium",
    exprs_values = "counts"
)
# Look at the results
head(rowData(sfe))

# Local Moran's I
sfe <- runUnivariate(sfe,
    type = "localmoran", features = features_use,
    colGraphName = "visium", exprs_values = "counts"
)
head(localResult(sfe, "localmoran", features_use[1]))

# For colData
sfe <- colDataUnivariate(sfe,
    type = "localmoran", features = "nCounts",
    colGraphName = "visium"
)
head(localResult(sfe, "localmoran", "nCounts"))

# For annotGeometries
annotGraph(sfe, "myofiber_tri2nb") <-
    findSpatialNeighbors(sfe,
        type = "myofiber_simplified", MARGIN = 3L,
        method = "tri2nb", dist_type = "idw",
        zero.policy = TRUE
    )
sfe <- annotGeometryUnivariate(sfe,
    type = "localG", features = "area",
    annotGraphName = "myofiber_tri2nb",
    annotGeometryName = "myofiber_simplified",
    zero.policy = TRUE
)
head(localResult(sfe, "localG", "area",
    annotGeometryName = "myofiber_simplified"
))
}
