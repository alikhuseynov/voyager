% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/moran-geary.R
\name{calculateMoranMC}
\alias{calculateMoranMC}
\alias{calculateGearyMC}
\alias{calculateMoranMC,ANY-method}
\alias{calculateGearyMC,ANY-method}
\alias{calculateMoranMC,SpatialFeatureExperiment-method}
\alias{calculateGearyMC,SpatialFeatureExperiment-method}
\alias{colDataMoranMC}
\alias{colDataGearyMC}
\alias{colGeometryMoranMC}
\alias{colGeometryGearyMC}
\alias{annotGeometryMoranMC}
\alias{annotGeometryGearyMC}
\alias{runMoranMC}
\alias{runGearyMC}
\title{Permutation test for Moran's I and Geary's C}
\usage{
\S4method{calculateMoranMC}{ANY}(
  x,
  listw,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

\S4method{calculateGearyMC}{ANY}(
  x,
  listw,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

\S4method{calculateMoranMC}{SpatialFeatureExperiment}(
  x,
  features,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

\S4method{calculateGearyMC}{SpatialFeatureExperiment}(
  x,
  features,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

colDataMoranMC(
  x,
  features,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

colDataGearyMC(
  x,
  features,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

colGeometryMoranMC(
  x,
  features,
  colGeometryName = 1L,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

colGeometryGearyMC(
  x,
  features,
  colGeometryName = 1L,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

annotGeometryMoranMC(
  x,
  features,
  annotGeometryName = 1L,
  annotGraphName = 1L,
  sample_id = NULL,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

annotGeometryGearyMC(
  x,
  features,
  annotGeometryName = 1L,
  annotGraphName = 1L,
  sample_id = NULL,
  nsim,
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  ...
)

runMoranMC(
  sfe,
  features,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  name = "MoranMC",
  ...
)

runGearyMC(
  sfe,
  features,
  colGraphName = 1L,
  sample_id = NULL,
  nsim,
  exprs_values = "logcounts",
  BPPARAM = SerialParam(),
  zero.policy = NULL,
  alternative = "greater",
  name = "GearyMC",
  ...
)
}
\arguments{
\item{x}{For \code{calculateMoransI} and \code{calculateGearysC}, it can be a
numeric matrix whose rows are features/genes, or a
\code{SpatialFeatureExperiment} (SFE) object with such a matrix in an
assay.}

\item{listw}{Weighted neighborhood graph as a \code{spdep} \code{listw}
object.}

\item{nsim}{number of permutations}

\item{BPPARAM}{A \code{\link{BiocParallelParam}} object specifying whether
and how computing the metric for numerous genes shall be parallelized.}

\item{zero.policy}{default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA}

\item{alternative}{a character string specifying the alternative hypothesis, must be one of "greater" (default), or "less".}

\item{...}{Other parameters passed to \code{\link{moran.mc}} or
\code{\link{geary.mc}}.}

\item{features}{Genes (\code{calculate*} SFE method and \code{run*}) or
numeric columns of \code{colData(x)} (\code{colData*}) or any
\code{\link{colGeometry}} (\code{colGeometryM*}) or
\code{\link{annotGeometry}} (\code{annotGeometry*}) for which the
univariate metric is to be computed. Default to \code{NULL}. When
\code{NULL}, then the metric is computed for all genes with the values in
the assay specified in the argument \code{exprs_values}. This can be
parallelized with the argument \code{BPPARAM}. For genes, if the column
"symbol" is present in \code{rowData} and the row names of the SFE object
are Ensembl IDs, then the gene symbol can be used and converted to IDs
behind the scene. However, if one symbol matches multiple IDs, a warning
will be given and the first match will be used.}

\item{colGraphName}{Name of the listw graph in the SFE object that
corresponds to entities represented by columns of the gene count matrix.
Use \code{\link{colGraphNames}} to look up names of the available graphs
for cells/spots. Note that for multiple \code{sample_id}s, it is assumed
that all of them have a graph of this same name.}

\item{sample_id}{Sample(s) in the SFE object whose cells/spots to use. Can be
"all" to compute metric for all samples; the metric is computed separately
for each sample.}

\item{exprs_values}{Integer scalar or string indicating which assay of x
contains the expression values.}

\item{colGeometryName}{Name of a \code{colGeometry} \code{sf} data frame
whose numeric columns of interest are to be used to compute the metric. Use
\code{\link{colGeometryNames}} to look up names of the \code{sf} data
frames associated with cells/spots.}

\item{annotGeometryName}{Name of a \code{annotGeometry} \code{sf} data frame
whose numeric columns of interest are to be used to compute the metric. Use
\code{\link{annotGeometryNames}} to look up names of the \code{sf} data
frames associated with annotations.}

\item{annotGraphName}{Name of the listw graph in the SFE object that
corresponds to the \code{annotGeometry} of interest. Use
\code{\link{annotGraphNames}} to look up names of available annotation
graphs.}

\item{sfe}{A \code{SpatialFeatureExperiment} object.}

\item{name}{String specifying the name to be used to store the results in
\code{rowData(x)}. If not already present in the name, then the
\code{sample_id} will be appended to the name specified here separated by
an underscore.}
}
\value{
For \code{calculateMoran/GearyMC}, a list of \code{mc.sim} objects.
  For the SFE method of \code{calculate*}, when more than one
  \code{sample_id} is specified, then a list of such lists, whose names are
  the \code{sample_id}s. For \code{runMoran/GearyMC}, the results are
  converted to a \code{DataFrame} and added to \code{rowData(x)}, and a SFE
  object with the added \code{rowData} is returned. For the colData,
  colGeometry, and annotGeometry versions, the results are added to the
  \code{featureData} attribute of the data frame of interest in a manner
  analogous to \code{rowData}.
}
\description{
Thin wrapper of \code{\link{moran.mc}} and \code{\link{geary.mc}} for easier
usage with the \code{SpatialFeatureExperiment} object and usage over multiple
genes. Multithreading is supported when computing for numerous genes.
}
\examples{
library(SpatialFeatureExperiment)
library(SingleCellExperiment)
library(SFEData)
sfe <- McKellarMuscleData("small")
colGraph(sfe, "visium") <- findVisiumGraph(sfe)
# Compute Moran's I with Monte Carlo testing for vector or matrix
calculateMoranMC(colData(sfe)$nCounts, listw = colGraph(sfe, "visium"),
                 nsim = 100)
# Add results to rowData, features are genes
sfe <- runMoranMC(sfe, features = rownames(sfe)[1], exprs_values = "counts",
                  nsim = 100)
rowData(sfe)
# Specifically for colData
sfe <- colDataMoranMC(sfe, "nCounts", nsim = 100)
attr(colData(sfe), "featureData")
}
