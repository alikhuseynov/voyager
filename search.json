[{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"visium-space-ranger-output","dir":"Articles","previous_headings":"","what":"Visium Space Ranger output","title":"Create a SpatialFeatureExperiment object","text":"10x Genomics Space Ranger output Visium experiment can read similar manner SpatialExperiment; SpatialFeatureExperiment SFE object spotPoly column geometry spot polygons. filtered matrix (.e. spots tissue) read , column graph called visium also present spatial neighborhood graph Visium spots tissue. graph computed spots read regardless whether tissue. results tissue capture outs directory. Inside outs directory two directories: raw_reature_bc_matrix unfiltered gene count matrix, spatial spatial information. DropletUtils package function read10xCounts() reads gene count matrix. SPE reads spatial information, SFE uses spatial information construct Visium spot polygons spatial neighborhood graphs. Inside spatial directory: tissue_lowres_image.png low re Inside scalefactors_json.json file: spot_diameter_fullres diameter Visium spot full resolution H&E image pixels. tissue_hires_scalef tissue_lowres_scalef ratio size high resolution (full resolution) low resolution H&E image full resolution image. fiducial_diameter_fullres diameter fiducial spot used align spots H&E image pixels full resolution image. tissue_positions_list.csv file contains information spatial coordinates spots whether spot tissue automatically detected Space Ranger manually annotated Loupe browser. polygon tissue boundary available, whether image processing manual annotation, geometric operations supported SFE package, based sf package, can used find spots intersect tissue spots contained tissue. Geometric operations can also find polygons intersections spots tissue, results can get messy since intersections can polygons also points lines. Now read toy data Space Ranger output format. load argument indicates whether images loaded memory. SFE package work image present, load = FALSE. Space Ranger output includes gene count matrix, spot coordinates, spot diameter. Space Ranger output include nuclei segmentation pathologist annotation histological regions. Extra image processing, ImageJ QuPath, required geometries.","code":"# Example from SpatialExperiment dir <- system.file(   file.path(\"extdata\", \"10xVisium\"),    package = \"SpatialExperiment\")    sample_ids <- c(\"section1\", \"section2\") (samples <- file.path(dir, sample_ids, \"outs\")) list.files(samples[1]) list.files(file.path(samples[1], \"spatial\")) fromJSON(file = file.path(samples[1], \"spatial\", \"scalefactors_json.json\")) (sfe3 <- read10xVisiumSFE(samples, sample_ids, type = \"sparse\", data = \"raw\",                          load = FALSE))"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"create-sfe-object-from-scratch","dir":"Articles","previous_headings":"","what":"Create SFE object from scratch","title":"Create a SpatialFeatureExperiment object","text":"SFE object can constructed scratch assay matrices metadata. toy example, dgCMatrix used, since SFE inherits SingleCellExperiment (SCE), types arrays supported SCE delayed arrays also work. sufficient create SPE object, SFE object, even though sf data frame constructed geometries. constructor behaves similarly SPE constructor. centroid coordinates Visium spots example can converted spot polygons spotDiameter argument, can also relevant technologies round spots beads, Slide-seq. Spot diameter pixels full resolution images can found scalefactors_json.json file Space Ranger output. geometries spatial graphs can added calling constructor. Geometries can also supplied constructor.","code":"# Visium barcode location from Space Ranger data(\"visium_row_col\") coords1 <- visium_row_col[visium_row_col$col < 6 & visium_row_col$row < 6,] coords1$row <- coords1$row * sqrt(3)  # Random toy sparse matrix set.seed(29) col_inds <- sample(1:13, 13) row_inds <- sample(1:5, 13, replace = TRUE) values <- sample(1:5, 13, replace = TRUE) mat <- sparseMatrix(i = row_inds, j = col_inds, x = values) colnames(mat) <- coords1$barcode rownames(mat) <- sample(LETTERS, 5) sfe3 <- SpatialFeatureExperiment(list(counts = mat), colData = coords1,                                 spatialCoordsNames = c(\"col\", \"row\"),                                 spotDiameter = 0.7) # Convert regular data frame with coordinates to sf data frame cg <- df2sf(coords1[,c(\"col\", \"row\")], c(\"col\", \"row\"), spotDiameter = 0.7) rownames(cg) <- colnames(mat) sfe3 <- SpatialFeatureExperiment(list(counts = mat), colGeometries = list(foo = cg))"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"gene-count-matrix-and-cell-metadata","dir":"Articles","previous_headings":"Create SFE object from scratch > Technology specific notes","what":"Gene count matrix and cell metadata","title":"Create a SpatialFeatureExperiment object","text":"gene count matrix cell metadata (including cell centroid coordinates) example datasets technologies CosMX Vizgen CSV files. recommend vroom package quickly read large CSV files. CSV files read data frames. gene count matrix, can converted matrix sparse dgCMatrix. matrix may need transposed genes rows cells columns. smFISH based data tend less sparse scRNA-seq data, using sparse matrix worthwhile since matrix still 50% zero. Vizgen MERFISH, first column cell ID doesn’t column name. cell IDs numbers 30 digits long. ’s read numbers, values change R doesn’t support long integers, instead read character. example : mat <- vroom(\"Liver1Slice1_cell_by_gene.csv\", col_types = cols(...1 = \"c\")), ...1 name vroom gives first column doesn’t column name, “c” specifies type character. Note Xenium Beta might soon change 10x Genomics’ new single cell resolution technology Xenium, gene count matrix h5 file, can read R SCE object DropletUtils::read10xCounts(). can converted SpatialExperiment, SpatialFeatureExperiment. cell metadata available CSV format, ’s also parquet format compact disk, can read R data frame arrow::read_parquet(). Example code:","code":"library(DropletUtils) library(arrow) sce <- read10xCounts(\"Xenium_FFPE_Human_Breast_Cancer_Rep1_cell_feature_matrix.h5\") cell_info <- read_parquet(\"Xenium_FFPE_Human_Breast_Cancer_Rep1_cells.parquet\") # Add the centroid coordinates to colData colData(sce) <- cbind(colData(sce), cell_info[,-1]) spe <- toSpatialExperiment(sce, spatialCoordsNames = c(\"x_centroid\", \"y_centroid\")) sfe <- toSpatialFeatureExperiment(spe)"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"cell-polygons","dir":"Articles","previous_headings":"Create SFE object from scratch > Technology specific notes","what":"Cell polygons","title":"Create a SpatialFeatureExperiment object","text":"File format cell polygons (available) different formats different technology. cell polygons sf data frames put colGeometries() SFE object. section explains number smFISH-based technologies. Note Xenium Beta might soon change Xenium, cell polygons come CSV parquet files can directly read R data frame, 2 columns x y coordinates, one indicating cell coordinates belong . Change name cell ID column “ID”, use SpatialFeatureExperiment::df2sf() convert data frame sf data frame POLYGON geometry. Example code: CoxMX, cell polygons CSV files. Besides two coordinates columns, ’s column field view (FOV) another cell ID. However, unlike Xenium, cell IDs unique FOV, concatenated FOV make unique. df2sf() can also used convert regular data frame sf. Example code: Vizgen MERFISH, cell polygons HDF5 files, one HDF5 file per FOV. HDF5 file seems contain 7 z-planes, least mouse liver MERFISH dataset SFEData, 7 z-planes polygons effect cell segmentation available one z-plane. Example code convert sf: See code used construct example datasets SFEData examples. Use sf::st_is_valid() check polygons valid. Polygons self-intersection valid, throw error geometric operations. common reason polygons invalid protruding line, can eliminated sf::st_buffer(cell_sf, dist = 0). Use sf::st_is_valid(cell_sf, reason = TRUE), plot invalid polygons, find polygons valid.","code":"library(arrow) cell_poly <- read_parquet(\"Xenium_FFPE_Human_Breast_Cancer_Rep2_cell_boundaries.parquet\") # Here the first column is cell ID names(cell_poly)[1] <- \"ID\" # \"vertex_x\" and \"vertex_y\" are the column names for coordinates here cell_sf <- df2sf(cell_poly, c(\"vertex_x\", \"vertex_y\"), geometryType = \"POLYGON\") library(vroom) library(tidyr) cell_poly <- vroom(\"Lung5_Rep1-polygons.csv\") cell_poly <- cell_poly |>      unite(\"ID\", fov:cellID) cell_sf <- df2sf(cell_poly, spatialCoordsNames = c(\"x_global_px\", \"y_global_px\"),                  geometryType = \"POLYGON\") library(rhdf5) library(dplyr) library(BiocParallel) h52poly_fov <- function(fn, i) {     l <- rhdf5::h5dump(fn)[[1]]     cell_ids <- names(l)     geometries <- lapply(l, function(m)         sf::st_polygon(list(t(m[[\"zIndex_0\"]]$p_0$coordinates[,,1]))))     df <- data.frame(geometry = sf::st_sfc(geometries),                      ID = cell_ids,                      fov = i)     sf::st_sf(df) } # Those hdf5 files are in the directory cell_boundaries fns <- list.files(\"cell_boundaries\", \"*.hdf5\", full.names = TRUE) # Multicore as there're over 1000 FOVs in this dataset # I ran this on a server.  # Use parallel::detectCores() to find how many CPU cores you have. cell_sfs <- bpmapply(h52poly_fov, fn = fns, i = seq_along(fns), SIMPLIFY = FALSE,                       BPPARAM = SnowParam(20, progressbar = TRUE)) # dplyr::bind_rows is much faster than base R's rbind cell_sf <- do.call(bind_rows, cell_sfs)"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Create a SpatialFeatureExperiment object","text":"","code":"sessionInfo()"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic Visium exploratory data analysis","text":"introductory vignette SpatialFeatureExperiment data representation Voyager anlaysis package, demonstrate basic exploratory data analysis (EDA) spatial transcriptomics data. Basic knowledge R SingleCellExperiment assumed. vignette showcases packages Visium spatial gene expression system dataset. technology chosen due popularity, therefore availability numerous publicly available datasets analysis (Moses Pachter 2022). code can run Google Colab. Voyager developed goal facilitating use geospatial methods spatial genomics, introductory vignette restricted non-spatial scRNA-seq EDA Visium dataset. vignette illustrating univariate spatial analysis dataset, see advanced exploratory spatial data analyis vignette dataset. load packages used vignette.","code":"library(Voyager) library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SpatialExperiment) library(scater) library(scran) library(patchwork) library(bluster) library(SFEData) library(BiocParallel) library(stringr) library(ggplot2) library(sparseMatrixStats) theme_set(theme_bw(10))"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"mouse-skeletal-muscle-dataset","dir":"Articles","previous_headings":"","what":"Mouse skeletal muscle dataset","title":"Basic Visium exploratory data analysis","text":"dataset used vignette paper Large-scale integration single-cell transcriptomic data captures transitional progenitor states mouse skeletal muscle regeneration (McKellar et al. 2021). Notexin injected tibialis anterior muscle mice induce injury, healing muscle collected 2, 5, 7 days post injury Visium analysis. dataset vignette timepoint day 2. vignette starts SpatialFeatureExperiment (SFE) object. gene count matrix directly downloaded GEO. 4992 spots, whether tissue , included. tissue boundary found thresholding H&E image OpenCV, small polygons removed likely debris. Spot polygons constructed spot centroid coordinates diameter Space Ranger output. in_tissue column colData indicates spot polygons intersect tissue polygons, based st_intersects(). Tissue boundary, nuclei, myofiber, Visium spot polygons stored sf data frames SFE object. Visium spot polygons called “spotPoly” SFE object. SpatialFeatureExperiment package convenience wrappers get set common types geometries, including spotPoly() Visium (technologies relevant) spot polygons, cellSeg() cell segmentation, nucSeg() nuclei segmentation, centroids() cell centroids. Behind scene specially named sf data frames. See vignette SpatialFeatureExperiment details structure SFE object. SFE object dataset provided SFEData package; begin downloading data loading R. authors provided full resolution hematoxylin eosin (H&E) image GEO, downsized facilitate display:","code":"(sfe <- McKellarMuscleData(\"full\"))"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"spots","dir":"Articles","previous_headings":"Quality control","what":"Spots","title":"Basic Visium exploratory data analysis","text":"begin quality control (QC) plotting various metrics violin plots space. QC metrics pre-computed stored colData (spots) rowData SFE object. plot total unique molecular identifier (UMI) counts per spot. commented line code shows compute total UMI counts. spots injury site leukocyte infiltration high total counts. Spatial autocorrelation total counts apparent, discussed later section vignette. Next find number genes detected per spot. commented line code shows find number genes detected. commonly done scRNA-seq data, plot nCounts vs. nGenes plot two branches spots tissue, turn related myofiber size. See exploratory spatial data analysis (ESDA) Visium vignette. commonly done scRNA-seq data, plot proportion mitochondrially encoded counts. commented code shows find proportion: expected, spots outside tissue higher proportion mitochondrial counts, tissue lysed, mitochondrial transcripts less likely degrade cytosolic transcripts protected double membrane. However, spots myofibers also high proportion mitochondrial counts, function myofibers. injury site leukocyte infiltration lower proportion mitochondrial counts. see relationship proportion mitochondrial counts total UMI counts, plot commonly done scRNA-seq analysis identify low quality cells, .e. cells UMI counts high proportion mitochondrial counts. two clusters spots tissue, also turn related myofiber size. See ESDA Visium vignette. far haven’t seen spots obvious outliers QC metrics. following analyses use spots tissue, selected follows:","code":"names(colData(sfe)) # colData(sfe)$nCounts <- colSums(counts(sfe)) violin <- plotColData(sfe, \"nCounts\", x = \"in_tissue\", colour_by = \"in_tissue\") +     theme(legend.position = \"top\") spatial <- plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"spotPoly\",                               annotGeometryName = \"tissueBoundary\") +     theme_void() violin + spatial # colData(sfe)$nGenes <- colSums(counts(sfe) > 0) violin <- plotColData(sfe, \"nGenes\", x = \"in_tissue\", colour_by = \"in_tissue\") +     theme(legend.position = \"top\") spatial <- plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"spotPoly\",                               annotGeometryName = \"tissueBoundary\") +     theme_void() violin + spatial plotColData(sfe, x = \"nCounts\", y = \"nGenes\", colour_by = \"in_tissue\") # mito_ind <- str_detect(rowData(sfe)$symbol, \"^Mt-\") # colData(sfe)$prop_mito <- colSums(counts(sfe)[mito_ind,]) / colData(sfe)$nCounts violin <- plotColData(sfe, \"prop_mito\", x = \"in_tissue\", colour_by = \"in_tissue\") +     theme(legend.position = \"top\") spatial <- plotSpatialFeature(sfe, \"prop_mito\", colGeometryName = \"spotPoly\",                               annotGeometryName = \"tissueBoundary\") +     theme_void() violin + spatial plotColData(sfe, x = \"nCounts\", y = \"prop_mito\", colour_by = \"in_tissue\") sfe_tissue <- sfe[, colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"genes","dir":"Articles","previous_headings":"Quality control","what":"Genes","title":"Basic Visium exploratory data analysis","text":"scRNA-seq, gene expression variance Visium measurements overdispersed compared variance counts Poisson distributed. understand mean-variance relationship, compute mean, variance, coefficient variance (CV2) gene among spots tissue: avoid overplotting better show point density plot, use 2D histogram. color bin indicates number points bin. red line, \\(y = x\\) expected Poisson distributed data, find variance higher highly expressed genes expected Poisson distributed counts. coefficient variation shows .","code":"rowData(sfe_tissue)$means <- rowMeans(counts(sfe_tissue)) rowData(sfe_tissue)$vars <- rowVars(counts(sfe_tissue)) # Coefficient of variance rowData(sfe_tissue)$cv2 <- rowData(sfe_tissue)$vars/rowData(sfe_tissue)$means^2 plotRowDataBin2D(sfe, \"means\", \"vars\", bins = 50) +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() plotRowDataBin2D(sfe, \"means\", \"cv2\", bins = 50) +     geom_abline(slope = -1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal()"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"normalize-data","dir":"Articles","previous_headings":"","what":"Normalize data","title":"Basic Visium exploratory data analysis","text":"demonstrate use scran (Lun, Bach, Marioni 2016) normalization , although note necessarily best approach normalizing spatial transcriptomics data. problem normalize spatial transcriptomics data non-trivial , nCounts plot space shows , spatial autocorrelation evident. Furthemrore, Visium, reverse transcription occurs situ spots, PCR amplification occurs cDNA dissociated spots. Artifacts may subsequently introduced amplification step, associated spatial origin. Spatial artifacts may arise diffusion transcripts tissue permeablization. However, given total counts seem correspond histological regions, total counts may biological component hence treated technical artifact normalized away scRNA-seq data normalization methods. words, issue normalization spatial transcriptomics data, Visium particular, complex currently unsolved. Next, identify highly variable genes, used principal component analysis (PCA) dimensionality reduction.","code":"clusters <- quickCluster(sfe_tissue) sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) dec <- modelGeneVar(sfe_tissue) hvgs <- getTopHVGs(dec, n = 2000)"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Dimension reduction and clustering","title":"Basic Visium exploratory data analysis","text":"clustering show dimension reduction plots principal components (PCs) can plotted space. Due spatial autocorrelation many genes spatial regions different histological characters, even though spatial information used PCA procedure, PCs may show spatial structure. PC1, explains far variance PC2, separates injury site leukocytes myofibers close site visium myofibers. PC2 highlight myofibers near edge. PC3 highlights muscle tendon junctions. PC4 seem informative; might picked outlier. also possible run UMAP following PCA, done scRNA-seq. recommend producing UMAP since procedure distorts distances, respect either local global structure data (Chari, Banerjee, Pachter 2021). However, completeness, show compute UMAP : interesting spatial transcriptomics, locate clusters space, can done follows: spatial information explicitly used clustering, due spatial autocorrelation gene expression histological regions, clusters spatially contiguous. many methods find spatially informed clusters, BayesSpace (E. Zhao et al. 2021), Bioconductor. Remark spatial regions: geographical space, usually one single way define spatial regions. example, influenced sociology geology, LA county can partitioned regions Eastside, Westside, South Central, San Fernado Valley, San Gabriel Valley, Pomona Valley, Gateway Cities, South Bay, etc., containing multiple smaller cities parts LA City, can divided many neighborhoods, Koreatown, Highland Park, Lincoln Heights, etc. Definitions regions subject dispute. Meanwhile, LA county can also partitioned watersheds LA River, San Gabriel River, Ballona Creek, etc., well different rock formations. kind spatial region resolution relevant depends question asked. also gray areas spatial regions. example, Whittier Narrows dam intercepts San Gabriel River Rio Hondo (large tributary LA River), whether dam area belongs watershed San Gabriel River LA River unclear. Similarly, spatial transcriptomics, methods identifying spatial regions currently generally aim give one result, multiple results different resolutions depending question asked may relevant. Furthermore, methods spatial region demarcation used spatial -omics ideally provide uncertainty assessments assignment cells Visium spots. existing geospatial method accounts uncertainty geocmeans (F. Zhao, Jiao, Liu 2013), CRAN. geographical histological space, conflicting views spatial variation. one hand, methods identify spatially variable genes SpatialDE often assume gene expression vary smoothly continuously space. hand, methods identifying spatial regions attempt identify discrete regions. continuous variation features might definitions geographical neighborhoods often subject dispute. existing methods attempt harmonize two views. example, spatially variable gene method belayer (Ma et al. 2022) takes discrete tissue layers account.","code":"sfe_tissue <- runPCA(sfe_tissue, ncomponents = 30, subset_row = hvgs,                      scale = TRUE) # scale as in Seurat ElbowPlot(sfe_tissue, ndims = 30) plotDimLoadings(sfe_tissue, dims = 1:4) colData(sfe_tissue)$cluster <- clusterRows(reducedDim(sfe_tissue, \"PCA\")[,1:3],                                            BLUSPARAM = SNNGraphParam(                                                cluster.fun = \"leiden\",                                                cluster.args = list(                                                    resolution_parameter = 0.5,                                                    objective_function = \"modularity\"))) plotPCA(sfe_tissue, ncomponents = 3, colour_by = \"cluster\") spatialReducedDim(sfe_tissue, \"PCA\", ncomponents = 4,                    colGeometryName = \"spotPoly\", divergent = TRUE,                    diverge_center = 0) &     theme_void() set.seed(29) sfe_tissue <- runUMAP(sfe_tissue, dimred = \"PCA\", n_dimred = 3) plotUMAP(sfe_tissue, colour_by = \"cluster\") plotSpatialFeature(sfe_tissue, \"cluster\", colGeometryName = \"spotPoly\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"non-spatial-differential-expression","dir":"Articles","previous_headings":"","what":"Non-spatial differential expression","title":"Basic Visium exploratory data analysis","text":"Cluster marker genes can found using differential analysis methods commonly done scRNA-seq. example Wilcoxon rank sum test: result sorted p-values: Significant markers cluster can obtained follows: genes interesting view spatial context:","code":"markers <- findMarkers(sfe_tissue, groups = colData(sfe_tissue)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[6]] genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe_tissue, rowData(sfe_tissue)[genes_use, \"symbol\"], x = \"cluster\",                colour_by = \"cluster\", swap_rownames = \"symbol\") plotSpatialFeature(sfe_tissue, genes_use, colGeometryName = \"spotPoly\") &     theme_void()"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moran’s I","title":"Basic Visium exploratory data analysis","text":"Tobler’s first law geography states Everything related everything else. near things related distant things. observation motivates examination spatial autocorrelation. Positive spatial autocorrelation evident nearby things tend similar, weather Pasadena downtown Los Angeles (opposed weather Pasadena San Francisco). Negative spatial autocorrelation evident nearby things tend dissimilar, like squares chessboard. Spatial autocorrelation can arise intrinsic process diffusion communication physical contact, result covariate intrinsic process, areal data, areal units observation smaller scale spatial process. commonly used measure spatial autocorrelation Moran’s , defined \\[ = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}, \\] \\(n\\) number spots locations, \\(\\) \\(j\\) different locations, spots Visium context, \\(x\\) variable values location, \\(w_{ij}\\) spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood whether normalize number neighbors. spdep package uses neighborhood. Moran’s similar Pearson correlation value location average value neighbors (identical, see (Lee 2001)). Just like Pearson correlation, Moran’s generally bound -1 1, positive value indicates positive spatial autocorrelation negative value indicates negative spatial autocorrelation. Spatial dependence analysis spdep requires spatial neighborhood graph. graph adjacent Visium spot can found mentioned spatial autocorrelation apparent total UMI counts. ’s Moran’s shows: K means kurtosis. positive values Moran’s indicate positive spatial autocorrelation.","code":"colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue) calculateMoransI(t(colData(sfe_tissue)[,c(\"nCounts\", \"nGenes\")]),                   listw = colGraph(sfe_tissue, \"visium\"))"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"spatially-variable-genes","dir":"Articles","previous_headings":"Moran’s I","what":"Spatially variable genes","title":"Basic Visium exploratory data analysis","text":"spatially variable gene gene whose expression depends spatial locations, rather spatially random, like salt grains spread soup. Spatially variable genes can identified spatial autocorrelation signatures, sometimes Moran’s used compare assess spatially variable genes identified different methods. BPPARAM used parallelize computation Moran’s 2000 highly variable genes, 2 cores used SNOW backend. results stored rowData NA’s genes highly variable Moran’s computed genes. rank genes Moran’s plot space follows: see genes strong positive spatial autocorrelation, don’t observe strong negative spatial autocorrelation. can plot genes strongest positive spatial autocorrelation space: genes indeed look spatially variable. However, spatial variability can simply due histological regions space, words, spatial distribution different cell types. many methods identify spatially variable genes, often involving Gaussian process modeling, far complex Moran’s , SpatialDE (Svensson, Teichmann, Stegle 2018). However, methods usually don’t account histological regions, except C-SIDE (Cable et al. 2022), identifies spatially variable genes within cell types. leads question really meant “cell type”. remains see spatial methods made specifically identifying spatially variable genes compare methods don’t explicitly use spatial information simply perform differential analysis cell types often spatially defined histological regions. Another consideration using Moran’s extent strength spatial autocorrelation varies space. gene exhibits strong spatial autocorrelation one region, another? different histological regions analyzed separately cases? ways see whether Moran’s statistically significant, many methods explore spatial autocorrelation. discussed advanced ESDA Visium vignette.","code":"sfe_tissue <- runMoransI(sfe_tissue, features = hvgs, colGraphName = \"visium\",                          BPPARAM = SnowParam(2)) rowData(sfe_tissue) df <- rowData(sfe_tissue)[hvgs,] ord <- order(df$moran_Vis5A, decreasing = TRUE) df[ord, c(\"symbol\", \"moran_Vis5A\")] plotSpatialFeature(sfe_tissue, rownames(df)[1:6], colGeometryName = \"spotPoly\") &     theme_void()"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Basic Visium exploratory data analysis","text":"","code":"sessionInfo()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spatial Visium exploratory data analysis","text":"vignette provides introduction exploratory spatial data analysis methods via Voyager package context Visium dataset.","code":"library(Voyager) library(SpatialFeatureExperiment) library(scater) library(scran) library(SFEData) library(sf) library(ggplot2) library(scales) library(patchwork) library(BiocParallel) library(bluster) theme_set(theme_bw(10))"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"Spatial Visium exploratory data analysis","text":"dataset used vignette paper Large-scale integration single-cell transcriptomic data captures transitional progenitor states mouse skeletal muscle regeneration (McKellar et al. 2021). Notexin injected tibialis anterior muscle mice induce injury, healing muscle collected 2, 5, 7 days post injury Visium analysis. dataset vignette timepoint day 2. vignette starts SpatialFeatureExperiment (SFE) object. gene count matrix directly downloaded GEO. 4992 spots, whether tissue , included. H&E image used nuclei myofiber segmentation. subset nuclei randomly selected regions 3 timepoints manually annotated train StarDist model segment rest nuclei, myofibers manually segmented. tissue boundary found thresholding OpenCV, small polygons removed likely debris. Spot polygons constructed spot centroid coordinates diameter Space Ranger output. in_tissue column colData indicates spot polygons intersect tissue polygons, based st_intersects(). Tissue boundary, nuclei, myofiber, Visium spot polygons stored sf data frames SFE object. See vignette SpatialFeatureExperiment details structure SFE object. SFE object dataset provided SFEData package; begin downloading data loading R. H&E image section:","code":"(sfe <- McKellarMuscleData(\"full\"))"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"spots-in-tissue","dir":"Articles","previous_headings":"Exploratory data analysis","what":"Spots in tissue","title":"Spatial Visium exploratory data analysis","text":"example dataset Visium spots whether tissue , spots intersect tissue used analyses. Total UMI counts (nCounts), number genes detected per spot (nGenes), proportion mitochondrially encoded counts (prop_mito) precomputed colData(sfe). plotSpatialFeature function can used visualize various attributes space: expression gene, colData values, geometry attributes colGeometry annotGeometry. Visium spots plotted polygons reflecting actual size relative tissue, rather points, case packages plot Visium data. plotting geometries performed hood geom_sf. tissue boundary found thresholding H&E image removing small polygons likely debris. in_tissue column colData(sfe) indicates Visium spot polygon intersects tissue polygon; can found SpatialFeatureExperiment::annotPred(). demonstrate use scran (Lun, Bach, Marioni 2016) normalization , although note necessarily best approach normalizing spatial transcriptomics data. problem normalize spatial transcriptomics data non-trivial , nCounts plot space shows , spatial autocorrelation evident. Furthemrore, Visium, reverse transcription occurs situ spots, PCR amplification occurs cDNA dissociated spots. Artifacts may subsequently introduced amplification step, associated spatial origin. Spatial artifacts may arise diffusion transcripts tissue permeablization. However, given total counts seem correspond histological regions, total counts may biological component hence treated technical artifact normalized away scRNA-seq data normalization methods. words, issue normalization spatial transcriptomics data, Visium particular, complex currently unsolved. Myofiber nuclei segmentation polygons available dataset annotGeometries field. Myofibers manually segmented, nuclei segmented StarDist trained manually segmented subset.","code":"names(colData(sfe)) sfe_tissue <- sfe[,colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,] clusters <- quickCluster(sfe_tissue) sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) annotGeometryNames(sfe_tissue)"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"from-myofibers-and-nuclei-to-visium-spots","dir":"Articles","previous_headings":"Exploratory data analysis > Spots in tissue","what":"From myofibers and nuclei to Visium spots","title":"Spatial Visium exploratory data analysis","text":"plotSpatialFeature() function can also used plot attributes geometries, .e. non-geometry columns sf data frames rowGeometries, colGeometries, annotGeometries fields SFE object. rowGeometries colGeometries, columns associated sf data frames rather rowData colData, allowed one can specify columns associate geometries (see st_agr documentation st_sf). attribute annotGeometry plotted along side gene expression colData colGeometry attribute, annotGeometry attribute plotted different color palette distinguish column associated values. myofiber polygons annotGeometries can plotted shown , colored cross section area observed tissue section. aes_use argument set color rather fill (default polygons) plot Visium spot outlines make myofiber polygons visible. fill argument set NA make Visium spots look hollow, size argument controls thickness outlines. annot_aes argument specifies column annotGeometry use specify values aesthstic, just like aes ggplot2 (aes_string precise, since tidyeval used ). annot_fixed argument (used ) can set fixed size, alpha, color, etc. annotGeometry. larger myofibers seem fewer total counts, possibly larger size myofibers dilutes transcripts. hints need normalization procedure. SpatialFeatureExperiment, can find number myofibers nuclei intersect Visium spot. predicate can anything implemented sf, example, number nuclei fully covered Visium spot can also found. default predicate st_intersects(). one--one mapping Visium spots myofibers. However, can relate attributes myofibers gene expression detected Visium spots. One way summarize attributes myofibers intersect (choose another better predicate implemented sf) spot, calculate mean, median, sum. can done annotSummary() function SpatialFeatureExperiment. default predicate st_intersects(), default summary function mean(). reveals relationship mean area myofibers intersecting Visium spot aspects spots, total counts gene expression. NAs designate spots intersecting myofibers, e.g. inflammatory region. Basic Visium vignette, encountered two mysterious branches two clusters nGenes vs. nCounts plot proportion mitochondrial counts vs. nCounts plot. Now see two clusters seem related myofiber size.","code":"plotSpatialFeature(sfe_tissue, features = \"nCounts\",                     colGeometryName = \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     annot_aes = list(fill = \"area\"),                     aes_use = \"color\", size = 0.5, fill = NA) colData(sfe_tissue)$n_myofibers <-    annotNPred(sfe_tissue, colGeometryName = \"spotPoly\",              annotGeometryName = \"myofiber_simplified\") plotSpatialFeature(sfe_tissue, features = \"n_myofibers\",                     colGeometryName = \"spotPoly\") colData(sfe_tissue)$mean_myofiber_area <-    annotSummary(sfe_tissue, \"spotPoly\", \"myofiber_simplified\",                 annotColNames = \"area\")[,1] # it always returns a data frame # The gray spots don't intersect any myofiber plotSpatialFeature(sfe_tissue, \"mean_myofiber_area\", \"spotPoly\") plotColData(sfe_tissue, x = \"nCounts\", y = \"nGenes\", colour_by = \"mean_myofiber_area\") plotColData(sfe_tissue, x = \"nCounts\", y = \"prop_mito\", colour_by = \"mean_myofiber_area\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"myofiber-types","dir":"Articles","previous_headings":"Exploratory data analysis > Spots in tissue","what":"Myofiber types","title":"Spatial Visium exploratory data analysis","text":"Marker genes: Myh7 (Type , slow twitch, aerobic), Myh2 (Type IIa, fast twitch, somewhat aerobic), Myh4 (Type IIb, fast twitch, anareobic), Myh1 (Type IIx, fast twitch, anaerobic), protocol (Wang, Yue, Kuang 2017) first examine Type myofibers. fast twitch muscle, don’t expect many slow twitch Type myofibers. Row names sfe_tissue Ensembl IDs order avoid ambiguity sometimes multiple Ensembl IDs gene symbol genes aliases. However, gene symbols shorter human readable Ensembl IDs, better suited display plots. plotSpatialFeature() function functions Voyager, even row names recorded Ensembl IDs, features argument can take gene symbols column called “symbols” rowData(sfe), function converts gene symbols Ensembl IDs. default, gene symbols shown plot, show_symbol argument can set FALSE show Ensembl IDs instead. one gene symbol matches multiple Ensembl IDs dataset, warning given. exprs_values argument specifies assay use, default “logcounts”, .e. log normalized data. default may may suitable practice given total UMI counts may biological relevance spatial data. Therefore, plot raw counts log normalized counts: marker gene type IIa myofibers shown . straightforward modify plotting display markers type IIb type IIx myofibers: Type IIa myofibers also tend clustered together left side tissue. SFE inherits SCE, non-spatial EDA plots scater package can also used: Plotting proportion mitochondrial counts vs. mean myofiber area, see two clusters, one higher proportion mitochondrial counts smaller area, another lower proportion mitochondrial counts average slightly larger area. Type IIa myofibers tend smaller area larger proportion mitochondrial counts.","code":"markers <- c(I = \"Myh7\", IIa = \"Myh2\", IIb = \"Myh4\", IIx = \"Myh1\") # Function specific for this vignette, with some hard coded values plot_counts_logcounts <- function(sfe, feature) {   p1 <- plotSpatialFeature(sfe, feature, \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     annot_aes = list(fill = \"area\"), aes_use = \"color\",                    fill = NA, size = 0.5, show_symbol = TRUE,                     exprs_values = \"counts\") +     ggtitle(\"Raw counts\")   p2 <- plotSpatialFeature(sfe, feature, \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     annot_aes = list(fill = \"area\"), aes_use = \"color\",                    fill = NA, size = 0.5, show_symbol = TRUE,                     exprs_values = \"logcounts\") +     ggtitle(\"Log normalized counts\")   p1 + p2 +     plot_annotation(title = feature) } plot_counts_logcounts(sfe_tissue, markers[\"I\"]) plot_counts_logcounts(sfe_tissue, markers[\"IIa\"]) gene_id <- rownames(sfe_tissue)[rowData(sfe_tissue)$symbol == markers[\"IIa\"]] plotColData(sfe_tissue, x = \"mean_myofiber_area\", y = \"prop_mito\",              colour_by = gene_id, by_exprs_values = \"logcounts\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"spatial-neighborhood-graphs","dir":"Articles","previous_headings":"","what":"Spatial neighborhood graphs","title":"Spatial Visium exploratory data analysis","text":"spatial neighborhood graph required compute spatial dependency metrics Moran’s Geary’s C. SpatialFeatureExperiment package wraps methods spdep find spatial neighborhood graphs, stored within SFE object (see spdep documentation gabrielneigh(), knearneigh(), poly2nb(), tri2nb()). Voyager package uses graphs spatial dependency analyses, based spdep first version, methods geospatial packages, also use spatial neighborhood graphs, may added later. Visium, spots hexagonal grid, spatial neighborhood graph straightforward. However, spatial technologies single cell resolution, e.g. MERFISH, different methods can used find spatial neighborhood graph. example, method “poly2nb” used myofibers, identifies myofiber polygons physically touch . zero.policy = TRUE allow singletons, .e. nodes without neighbors graph; inflamed region, singletons. yet benchmarked spatial neighborhood construction methods determine “best” different technologies; particular method used demonstration purposes may best practice: plotColGraph() function plots graph space associated colGeometry, along geometry interest. Similarly, plotAnnotGraph() function plots graph associated annotGeometry, along geometry interest. plotRowGraph yet since haven’t worked dataset spatial graphs related genes relevant, although SFE object supports row graphs.","code":"colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue) annotGraph(sfe_tissue, \"myofiber_poly2nb\") <-    findSpatialNeighbors(sfe_tissue, type = \"myofiber_simplified\", MARGIN = 3,                        method = \"poly2nb\", zero.policy = TRUE) plotColGraph(sfe_tissue, colGraphName = \"visium\", colGeometryName = \"spotPoly\") plotAnnotGraph(sfe_tissue, annotGraphName = \"myofiber_poly2nb\",                 annotGeometryName = \"myofiber_simplified\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"exploratory-spatial-data-analysis","dir":"Articles","previous_headings":"","what":"Exploratory spatial data analysis","title":"Spatial Visium exploratory data analysis","text":"spatial autocorrelation metrics package can computed directly vector matrix rather SFE object. user interface emulates dimension reductions scater package (e.g. calculateUMAP() takes matrix SCE object returns matrix, runUMAP() takes SCE object adds results reducedDims field SCE object). calculate* functions take matrix SFE object directly return results (format results depends structure results), run* functions take SFE object add results object. addition, colData* functions compute metrics numeric variables colData. colGeometry* functions compute metrics numeric columns colGeometry. annotGeometry* functions compute metrics numeric columns annotGeometry.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"univariate-global","dir":"Articles","previous_headings":"","what":"Univariate global","title":"Spatial Visium exploratory data analysis","text":"Currently Voyager supports univariate global spatial autocorrelation implemented spdep ESDA: Moran’s Geary’s C, permutation testing Moran’s Geary’s C, Moran plot, correlograms. addition, beyond spdep, Voyager can cluster Moran plots correlograms. Plotting functions taking SFE objects implemented plot results ggplot2 customization options spdep plotting functions. functions calculateUnivariate(), runUnivariate(), colDataUnivariate(), colGeometryUnivariate(), annotGeometryUnivariate() compute univariate spatial statistics. univariate methods implemented R package spdep supported . argument type, indicates corresponding function names spdep, determines spatial statistics computed. demonstrate spatial autocorrelation gene expression, top highly variable genes (HVGs) used. HVGs found scran method. global statistic yields one result entire dataset.","code":"dec <- modelGeneVar(sfe_tissue) hvgs <- getTopHVGs(dec, n = 50)"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"morans-i","dir":"Articles","previous_headings":"Univariate global","what":"Moran’s I","title":"Spatial Visium exploratory data analysis","text":"several ways quantify spatial autocorrelation, common Moran’s : \\[ = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}, \\] \\(n\\) number spots locations, \\(\\) \\(j\\) different locations, spots Visium context, \\(x\\) variable values location, \\(w_{ij}\\) spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood whether normalize number neighbors. spdep package uses neighborhood. Moran’s can understood Pearson correlation value location average value neighbors. Just like Pearson correlation, Moran’s generally bound -1 1, positive value indicates positive spatial autocorrelation negative value indicates negative spatial autocorrelation. Upon visual inspection, total UMI counts per spot seem spatial autocorrelation. spatial neighborhood graph required compute Moran’s , specified listw argument. matrices, rows features, gene count matrix. “moran” Moran’s , K sample kurtosis. add results SFE object, specifically colData: colData, results added colFeatureData(sfe), features Moran’s calculated NA. column names featureData distinguishes different samples (’s one sample dataset), parsed plotting functions. add results SFE object, specifically geometries: “area” area cross section myofiber seen tissue section “eccentricity” eccentricity ellipse fitted myofiber. non-geometry column colGeometry, colGeometryUnivariate() like annotGeometryUnivariate() , none colGeometries dataset extra columns. gene expression, logcounts assay used default (use exprs_values argument change assay), though may may best practice. metrics computed large number features, parallel computing supported, BiocParallel, BPPARAM argument.","code":"# Directly use vector or matrix, and multiple features can be specified at once calculateUnivariate(t(colData(sfe_tissue)[,c(\"nCounts\", \"nGenes\")]),                      type = \"moran\",                     listw = colGraph(sfe_tissue, \"visium\")) sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                 colGraphName = \"visium\", type = \"moran\") head(colFeatureData(sfe_tissue), 10) # Remember zero.policy = TRUE since there're singletons sfe_tissue <- annotGeometryUnivariate(sfe_tissue, type = \"moran\",                                       features = c(\"area\", \"eccentricity\"),                                        annotGeometryName = \"myofiber_simplified\",                                       annotGraphName = \"myofiber_poly2nb\",                                        zero.policy = TRUE) head(attr(annotGeometry(sfe_tissue, \"myofiber_simplified\"), \"featureData\")) sfe_tissue <- runUnivariate(sfe_tissue, type = \"moran\", features = hvgs,                              colGraphName = \"visium\",                              BPPARAM = MulticoreParam(2)) rowData(sfe_tissue)[head(hvgs),]"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"gearys-c","dir":"Articles","previous_headings":"Univariate global","what":"Geary’s C","title":"Spatial Visium exploratory data analysis","text":"Another spatial autocorrelation metric Geary’s C, defined : \\[ C = \\frac{(n-1)}{2\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}(x_i - x_j)^2}{{\\sum_{=1}^n (x_i - \\bar{x})^2}} \\] Geary’s C 1 indicates positive spatial autocorrelation, 1 indicates negative spatial autocorrelation. compute Geary’s C features interest replace type = \"moran\" previous section type = \"geary\", add results SFE object. example, colData ’s one column K since ’s Moran’s Geary’s C. Moran’s Geary’s C suggest positive spatial autocorrelation nCounts nGenes. univariate global methods, including permutation testing Moran’s Geary’s C, correlograms, Moran scatter plot can also called functions runUnivariate, specifying type argument. See documentation runUnivariate see available methods see documentation corresponding spdep functions see extra arguments required method.","code":"sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                 colGraphName = \"visium\", type = \"geary\") head(colFeatureData(sfe_tissue), 10)"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"permutation-testing","dir":"Articles","previous_headings":"Univariate global","what":"Permutation testing","title":"Spatial Visium exploratory data analysis","text":"establish whether spatial autocorrelation statistically significant, moran.test() function spdep can used. provides p-value, p-value may accurate data normally distributed. gene expression data generally normally distributed data normalization doesn’t always work well, use permutation testing test significance Moran’s Geary’s C, wrapping moran.mc() spdep. “mc” stands Monte Carlo. nsim argument specifies number simulations. following adds results SFE object: Note test performed multiple features, p-values corrected multiple hypothesis testing. results can plotted: default, colorblind friendly palette dittoSeq used categorical variables. density Moran’s simulations values permuted disconnected spatial locations, vertical line actual Moran’s value. simulation indicates spatial autocorrelation significant. Use type = \"geary.mc\" permutation testing Geary’s C.","code":"set.seed(29) sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                  colGraphName = \"visium\", nsim = 100,                                 type = \"moran.mc\") head(colFeatureData(sfe_tissue), 10) plotMoranMC(sfe_tissue, c(\"nCounts\", \"nGenes\"))"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"correlogram","dir":"Articles","previous_headings":"Univariate global","what":"Correlogram","title":"Spatial Visium exploratory data analysis","text":"correlogram, spatial autocorrelation higher orders neighbors (e.g. second order neighbors neighbors neighbors) calculated see decays orders. Visium, regular hexagonal grid, order neighbors proxy distance. irregular patterns single cells, different methods find spatial neighbors may give different results. colData, Moran’s correlogram computed results can plotted plotCorrelogram: error bars twice standard deviation Moran’s value. standard deviation p-values (null hypothesis Moran’s 0) come moran.test() (Geary’s C correlogram, geary.test()); taken grain salt data normally distributed. p-values corrected multiple hypothesis testing across orders features. usual, . means p < 0.1, * means p < 0.05, ** means p < 0.01, *** means p < 0.001. , can done Geary’s C, colData, annotGeometry, etc.","code":"sfe_tissue <- runUnivariate(sfe_tissue, hvgs[1:2], colGraphName = \"visium\",                              order = 10, type = \"sp.correlogram\") plotCorrelogram(sfe_tissue, hvgs[1:2])"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"moran-scatter-plot","dir":"Articles","previous_headings":"Univariate global","what":"Moran scatter plot","title":"Spatial Visium exploratory data analysis","text":"Moran scatter plot, x axis value spot, y axis average value neighbors. slope fitted line Moran’s . Sometimes clusters appear plot, showing different kinds neighborhoods. gene expression, use one gene (log normalized value) demonstrate: dashed lines mark mean Myh2 spatially lagged Myh2. singletons . Visium spots lower Myh2 expression neighbors don’t express Myh2 spots don’t express Myh2 usually least neighbors . twp main clusters spots whose neighbors express Myh2: high (average) expression whose neighbors also high expression, low expression whose neighbors also low expression. features may show different kinds clusters. can use k-means clustering identify clusters, though clustering method supported bluster package can used. Plot clusters space can also done colData, annotGeometry, etc. Moran’s permutation testing.","code":"sfe_tissue <- runUnivariate(sfe_tissue, \"Myh2\", colGraphName = \"visium\",                              type = \"moran.plot\") moranPlot(sfe_tissue, \"Myh2\", graphName = \"visium\") set.seed(29) clusts <- clusterMoranPlot(sfe_tissue, \"Myh2\", BLUSPARAM = KmeansParam(2)) moranPlot(sfe_tissue, \"Myh2\", graphName = \"visium\", color_by = clusts$ENSMUSG00000033196) colData(sfe_tissue)$Myh2_moranPlot_clust <- clusts$ENSMUSG00000033196 plotSpatialFeature(sfe_tissue, \"Myh2_moranPlot_clust\", colGeometryName = \"spotPoly\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"univariate-local","dir":"Articles","previous_headings":"","what":"Univariate local","title":"Spatial Visium exploratory data analysis","text":"Local statistics yield result location rather whole dataset, global statistics may obscure local heterogeneity. Local statistics stored localResults field SFE object, can accessed localResult() localResults() functions SpatialFeatureExperiment package.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"local-morans-i","dir":"Articles","previous_headings":"Univariate local","what":"Local Moran’s I","title":"Spatial Visium exploratory data analysis","text":"recap, global Moran’s (Anselin 1995) defined \\[ = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}. \\] Local Moran’s defined \\[ I_i = (n-1)\\frac{(x_i - \\bar{x})\\sum_{j=1}^n w_{ij} (x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}. \\] ’s similar global Moran’s , values locations \\(\\) summed ’s normalization sum spatial weights. useful plot log normalized Myh2 gene expression context interpret local results: see regions higher Myh2 expression also stronger spatial autocorrelation. interesting see spatial autocorrelation relates gene expression level, much finding variance relates mean expression gene, usually indicates overdispersion compared Poisson scRNA-seq Visium data: gene, Visium spots higher expression also tend higher local Moran’s , may may apply genes. Local spatial analyses often return matrix data frame. plotLocalResult() function default column local spatial method, columns can plotted well. Use localResultAttrs() function see columns present, use attribute argument specify column plot. local spatial methods return p-values location, column name like Pr(z != E(Ii)), test two sided (default, can changed alternative argument runUnivariate() passed relevant underlying function spdep). Negative log p-value computed facilitate visualization, p-value corrected multiple hypothesis testing p.adjustSP() spdep, number tests number neighbors location rather total number locations (-log10p_adj). plot following plots p-values, divergent palette used show locations significant adjusting multiple testing significant different colors. center divergent palette p = 0.05, bluish spots significant dark brown means really significant. “pysal” column displays quadrants relative means Moran plot. result similar k-means clustering shown .","code":"sfe_tissue <- runUnivariate(sfe_tissue, type = \"localmoran\", features = \"Myh2\",                             colGraphName = \"visium\") plotSpatialFeature(sfe_tissue, features = \"Myh2\", colGeometryName = \"spotPoly\") plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\",divergent = TRUE,                 diverge_center = 0) qplot(logcounts(sfe_tissue)[rowData(sfe_tissue)$symbol == \"Myh2\",],       localResult(sfe_tissue, \"localmoran\", \"Myh2\")[,\"Ii\"],       xlab = \"Myh2 (log counts)\", ylab = \"localmoran\", alpha = I(0.3)) localResultAttrs(sfe_tissue, \"localmoran\", \"Myh2\") plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", attribute = \"-log10p_adj\", divergent = TRUE,                 diverge_center = -log10(0.05)) plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", attribute = \"pysal\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"getis-ord-gi","dir":"Articles","previous_headings":"Univariate local","what":"Getis-Ord Gi*","title":"Spatial Visium exploratory data analysis","text":"Getis-Ord Gi* used find hotspots coldspots feature space. hotspot cluster high values space, coldspot cluster low values space. Getis-Ord Gi* essentially z-score spatially lagged value feature location \\(\\) ($j w{ij}x_j $), \\(w_{ij}\\) spatial weight. original publication Getis-Ord Gi* 1992 (Getis Ord 1992), spatial weight distance-based binary weight indicating whether another location within certain distance location \\(\\). Getis-Ord Gi excludes location \\(\\) computation mean variance lagged value, Gi* includes location \\(\\) . Usually Gi Gi* yield similar results. mean variance used z-score differ Gi Gi* described paper 1995 (J. K. Ord Getis 1995) derived 1992 paper . Binary weights recommended Getis-Ord Gi*. High values Gi* indicate hotspots, low values Gi* indicate coldspots. Plot pseudo-p-values simulation hotspots expected. Local results can also computed annotation geometries. hotspots coldspots expected.","code":"colGraph(sfe_tissue, \"visium_B\") <- findVisiumGraph(sfe_tissue, style = \"B\") sfe_tissue <- runUnivariate(sfe_tissue, type = \"localG_perm\", features = \"Myh2\",                             colGraphName = \"visium_B\", include_self = TRUE) plotLocalResult(sfe_tissue, \"localG_perm\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", divergent = TRUE,                 diverge_center = 0) localResultAttrs(sfe_tissue, \"localG_perm\", \"Myh2\") plotLocalResult(sfe_tissue, \"localG_perm\", features = \"Myh2\",                  attribute = \"-log10p_adj Sim\",                 colGeometryName = \"spotPoly\", divergent = TRUE,                 diverge_center = -log10(0.05)) annotGraph(sfe_tissue, \"myofiber_poly2nb_B\") <-    findSpatialNeighbors(sfe_tissue, type = \"myofiber_simplified\", MARGIN = 3,                        method = \"poly2nb\", zero.policy = TRUE, style = \"B\") sfe_tissue <- annotGeometryUnivariate(sfe_tissue, \"localG_perm\", \"area\",                                        annotGeometryName = \"myofiber_simplified\",                                       annotGraphName = \"myofiber_poly2nb_B\",                                       include_self = TRUE, zero.policy = TRUE) plotLocalResult(sfe_tissue, \"localG_perm\", \"area\",                  annotGeometryName = \"myofiber_simplified\",                 divergent = TRUE, diverge_center = 0) plotLocalResult(sfe_tissue, \"localG_perm\", \"area\",                  annotGeometryName = \"myofiber_simplified\",                 attribute = \"-log10p_adj Sim\",                 divergent = TRUE, diverge_center = -log10(0.05))"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"local-spatial-heteroscedasticity-losh","dir":"Articles","previous_headings":"Univariate local","what":"Local spatial heteroscedasticity (LOSH)","title":"Spatial Visium exploratory data analysis","text":"LOSH (J. Keith Ord Getis 2012) defined \\[ H_i = \\frac{\\sum_j w_{ij}\\left| e_j \\right|^}{h_1\\sum_j w_{ij}} \\] \\(h_1 = \\sum_i \\left| e_i \\right|^/n\\) \\(e_j = x_j - \\bar{x}_j\\), \\[ \\bar{x}_j = \\frac{\\sum_j w_{jk}x_k}{\\sum_j w_{jk}}. \\] default, \\(= 2\\) LOSH like local variance. See (J. Keith Ord Getis 2012) details interpretation. gene, isn’t clear whether LOSH relates gene expression levels. Voyager wrap LOSH.mc() perform permutation testing LOSH, time consuming. chi-squared approximation described 2012 LOSH paper account non-normality data approximate mean variance permutation distributions, p-values LOSH can quickly computed, LOSH.cs(). gene, local conditions mostly homogenous, exceptions around edge tissue.","code":"sfe_tissue <- runUnivariate(sfe_tissue, \"LOSH.cs\", \"Myh2\",                              colGraphName = \"visium\") plotLocalResult(sfe_tissue, \"LOSH.cs\", features = \"Myh2\",                  colGeometryName = \"spotPoly\") localResultAttrs(sfe_tissue, \"LOSH.cs\", \"Myh2\") plotLocalResult(sfe_tissue, \"LOSH.cs\", features = \"Myh2\",                  attribute = \"-log10p_adj\", colGeometryName = \"spotPoly\",                 divergent = TRUE, diverge_center = -log10(0.05))"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"caveats","dir":"Articles","previous_headings":"","what":"Caveats","title":"Spatial Visium exploratory data analysis","text":"current version Voyager, univariate spatial autocorrelation metrics supported. Anisotropy, bivariate, multivariate spatial analyses added later versions. plotting functions don’t plot H&E image background. implemented first version since Visium spots plotted, block H&E image anyway. Also, plots small interactive, good enough visualizing gene expression Visium spots, H&E image informative zoomed . Interactive data visualization beyond scope package. ’s convoluted trick geom_sf flipping y axis, since coordinates pixels full resolution image image origin top left. 2D data supported present, although principle, sf GEOS support 3D data. present, runUnivariate type different parameter called, existing results overwritten. next version Voyager, may append non-default parameters names localResults relevant column names rowData keep record parameters distinguish results different parameters, case results compared. Spatial neighborhoods make sense within tissue section. multiple tissue sections, biological replica, different conditions? mouse brain, different biological replica can registered Allen Common Coordinate Framework (CCF) spatially comparable. Indeed, interesting see biological variability healthy wild type gene expression fine scaled region brain. However, CCF tissues without stereotypical structure, adipose skeletal muscle. don’t good solution spatially compare different tissue sections yet. Perhaps global spatial statistics whole section histological regions within section can compared. problem remains select informative metrics compare. Perhaps spatially-informed dimension reduction method, taking gene count matrix, also adjacency matrices spatial neighborhood graphs (different sections different blocks matrix) projecting cells Visium spots different sections shared low dimensional space can facilitate comparison. batch effect must corrected, dimension reduction interpretable, scalable.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Spatial Visium exploratory data analysis","text":"","code":"sessionInfo()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Slide-Seq V2 Exploratory Data Analysis","text":"Slide-seq V2 spatial transcriptomic tool measures genome-wide expression using DNA-barcoded beads patterned slide non-regular array. beads used current protocol diameter \\(10 \\mu m\\) thus larger single cell, number detected transcripts order magnitude higher compared previous iteration technology. vignette, use Voyager analyze dataset generated using Slide-Seq V2 technology. data described Dissecting treatment-naive ecosystem human melanoma brain metastasis. raw counts cell metadata publicly available GEO. focus one human melanoma brain metastasis (MBM) samples provided SFEData package SpatialFeatureExperiment(SFE) object. SFE object contains raw counts, QC metrics number UMIs genes detected per barcode, centroid coordinates barcode sf POINT geometry. SFE object SFEData package includes information 27,566 features 29,536 beads/barcodes.","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(scater) library(scran) library(bluster) library(ggplot2) library(patchwork) library(spdep) library(BiocParallel)  theme_set(theme_bw()) (sfe <- BiermannMelaMetasData(dataset =\"MBM05_rep1\"))"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"quality-control-qc","dir":"Articles","previous_headings":"","what":"Quality control (QC)","title":"Slide-Seq V2 Exploratory Data Analysis","text":"can begin performing exploratory data analysis barcodes tissue. pre-computed QC measures stored object. Total UMI counts (nCounts), number genes detected per spot (nGenes), proportion mitochondrially encoded counts (prop_mito). , plot total number UMI counts per barcode violin plot space. latter task, leverage function plotSpatialFeature() uses geom_sf() plot geometries applicable. first lines compute average number UMI counts per barcode average plotted red line vilin plot. barcode represented sf POINT geometry plot , note many beads quite low UMI counts, small regions throughout tissue appear high counts. perhaps due high cellular density melanoma cells, can speculate without image tissue. Interestingly, barcodes 0 counts. contrast many scRNA-seq dataset many cells zero counts. Given density points, may choose aggregate points hexagonal grid avoid overplotting. hexagon colored total number UMI counts space hexagon may represent one barcode. worthwhile note cell segmentation data included dataset. Even though Slide-Seq V2 profile gene expression single cell resolution, cell segmentation data can flexibly stored annotGeometries SFE object. geometries can plotted barcode-level data can used sf operations like finding number barcodes localized single cell. plot visualizes number UMI counts per barcode log scale. appears barcodes higher counts co-localized regions throughout tissue, however, regions rather small may suggest spatial autocorrelation. Next find number genes detected per barcode. , QC feature provided nGenes colData attribute barcodes. Similar number UMI counts per barcode, seem small regions higher number genes throughout tissue. may correspond regions cellular diversity high cellular density, might expected context melanoma. can compute degree number UMI counts per barcode depends spatial location measurement. relationship, spatial autocorrelation, can quantified using Moran’s index spatial autocorrelation, Moran’s . computation Moran’s requires first definition constitutes objects “near” . simply, represented spatial weights matrix. One possible representation adjacency matrix. matrix can computed polygonal data resulting matrix can binary, entries 1 polygons share border, 0 elsewhere (including diagonal). entries can weighted different ways, including length border shared two polygons. schema necessarily lend well spatial transcriptomic technologies, polygonal boundaries cell objects may correspond measurements count matrix, individual spots barcodes may correspond multiple neighborhoods cells. Certainly, interpretation spatial weights matrix change depending technology. case, can generate putative spatial graph using k-nearest neighbors algorithm. implemented findSpatialNeighbors() function argument method = \"knearneigh\" . store result colGraphs() slot SFE object. Now compute Moran's barcode QC metrics using colDataMoransI(). results substantiate visual check spatial autocorrelation. continue investigating QC metrics. proportion UMIs mapping mitochondrial genes useful metric assessing cell quality scRNA-seq data. examine QC metric plotting versus total number UMI counts barcode. keeping expectations, barcodes associated fewer counts appear associated higher proportions mitochondrial reads. exclude barcodes containing >10% mitochondrial reads subsequent analysis. second line removes barcodes zero counts, necessary dataset barcodes zero counts. keep just demonstrate method.","code":"names(colData(sfe)) avg <- as.data.frame(colData(sfe)) |>   dplyr::summarise(across(-sample_id, mean))  violin <- plotColData(sfe, \"nCounts\") +   geom_hline(aes(yintercept = nCounts), avg, color=\"red\") +   theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, features = \"nCounts\",                                colGeometryName = \"centroids\") violin + spatial as.data.frame(cbind(spatialCoords(sfe), colData(sfe))) |>      ggplot(aes(xcoord, ycoord, z=nCounts)) +     stat_summary_hex(fun = function(x) sum(x), bins=100) +      scale_fill_distiller(palette = \"Blues\", direction = 1) +     labs(fill='nCounts')  +     theme_bw() + coord_equal() +     scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) colData(sfe)$log_nCounts <- log(colData(sfe)$nCounts)  avg <- as.data.frame(colData(sfe)) |>   dplyr::summarise(across(-sample_id, mean))  violin <- plotColData(sfe, \"log_nCounts\") +   geom_hline(aes(yintercept = log_nCounts), avg, color=\"red\") +   theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, features = \"log_nCounts\",                                colGeometryName = \"centroids\") violin + spatial violin <- plotColData(sfe, \"nGenes\") +    geom_hline(aes(yintercept = nGenes), avg, color=\"red\") +   theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, features = \"nGenes\",                                colGeometryName = \"centroids\") violin + spatial colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                               dist_type = \"idw\", k = 5,                                                style = \"W\") features_use <- c(\"nCounts\", \"nGenes\") sfe <- colDataMoransI(sfe, features_use, colGraphName = \"knn5\") colFeatureData(sfe)[features_use,] violin <- plotColData(sfe, \"prop_mito\") +    geom_hline(aes(yintercept = prop_mito), avg, color=\"red\") +   theme(legend.position = \"top\")   mito <- plotColData(sfe, x = \"nCounts\", y = \"prop_mito\")  violin + mito # Spatial neighborhood graph is reconstructed when subsetting columns # Use drop = TRUE to drop the graph without reconstruction, whose indices are  # no longer valid sfe_filt <- sfe[, colData(sfe)$prop_mito < 0.1] sfe_filt <- sfe_filt[rowSums(counts(sfe_filt)) > 0,]"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"data-normalization","dir":"Articles","previous_headings":"","what":"Data Normalization","title":"Slide-Seq V2 Exploratory Data Analysis","text":"Normalization spatial transcriptomics data non-trivial requires thoughtful consideration. Like scRNA-seq data analysis, goal normalization remove effects technical variation derive quantity reflects biological variation. However, several questions arise considering best practices spatial data normalization. example, spatial methods average detect fewer UMIs single-cell counterparts, may preclude use normalization techniques log transformation shown . ’s , always evident whether spatial autocorrelation genes (QC measures) artifact technology, thus, whether normalization methods preserve spatial autocorrelation architecture. questions provide avenues active research development, currently unresolved. end, log-normalize data cell identify variable genes subsequent analysis.","code":"sfe_filt <- logNormCounts(sfe_filt)  dec <- modelGeneVar(sfe_filt) hvgs <- getTopHVGs(dec, n = 2000)"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Dimension Reduction and Clustering","title":"Slide-Seq V2 Exploratory Data Analysis","text":"Much like scRNA-seq analysis, perform principal component analysis (PCA) clustering. note method use spatial information. can plot variance explained PC. see first components explain variance data. principal components (PCs) can plotted space. notice PCs may show spatial structure correlates biological niches cells. Without cellular overlays, can speculate potential relevance barcodes seem separated PC, PC doe seem separate distinct neighborhoods barcodes. Now can cluster barcodes using graph-based clustering algorithm plot space. plot colored cluster id. naive interpretation plot shows distinct niches barcodes separated abundant, intervening types. may indicative biological processes hand, namely melanoma metastasis, ‘hotspots’ melanoma proliferation separated unaffected normal tissue.","code":"sfe_filt <- runPCA(sfe_filt, ncomponents = 30, subset_row = hvgs,                      scale = TRUE) # scale as in Seurat ElbowPlot(sfe_filt, ndims = 30) + theme_bw() spatialReducedDim(sfe_filt, \"PCA\", ncomponents = 4,                    colGeometryName = \"centroids\", divergent = TRUE,                    diverge_center = 0) &     theme_void() colData(sfe_filt)$cluster <- clusterRows(reducedDim(sfe_filt, \"PCA\")[,1:3],                                            BLUSPARAM = SNNGraphParam(                                                cluster.fun = \"leiden\",                                                cluster.args = list(                                                    resolution_parameter = 0.5,                                                    objective_function = \"modularity\"))) plotSpatialFeature(sfe_filt, \"cluster\", colGeometryName = \"centroids\") +   guides(colour = guide_legend(override.aes = list(size=3)))"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"morans-i","dir":"Articles","previous_headings":"Dimension Reduction and Clustering","what":"Moran’s I","title":"Slide-Seq V2 Exploratory Data Analysis","text":"One avenue future analysis includes identifying genes differentially expressed cluster, can interrogated findMarkers() non-spatial context calculateMoransI() spatial context. spatial case, consideration given whether differences seen across tissue represent biological difference artifacts field view. run global Moran’s log normalized gene expression. Now, might ask: genes display spatial autocorrelation? Spatial variability can also investigated using differential expression testing known anatomical regions complemented spatial location. One potential drawback approach variability induced melanoma, rather native tissue architecture, may preclude identification typical structures. analyses can done stage: 1. gene expression patterns, , differentiate neighborhoods melanoma cells? 2. genes differentially expressed cluster?","code":"sfe_filt <- runMoransI(sfe_filt, features = hvgs,                         BPPARAM = MulticoreParam(2)) top_moran <- rownames(sfe_filt)[order(rowData(sfe_filt)$moran_sample01, decreasing = TRUE)[1:4]] plotSpatialFeature(sfe_filt, top_moran, colGeometryName = \"centroids\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Slide-Seq V2 Exploratory Data Analysis","text":"","code":"sessionInfo()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"CosMX non-small cell lung cancer data","text":"Nanostring GeoMX DSP popular spatial transcriptomics technology formalin fixed paraffin embedded (FFPE) tissues, doesn’t single cell resolution. CosMX FISH based technology FFPE tissue (et al. 2021) single cell resolution, vignette provides example analyze CosMX data voyager. Note FFPE common way preserve archive tissue, cases, samples available may FFPE. CosMX dataset non-small cell lung cancer used described (et al. 2021). processed data available download Nanostring website. gene count matrix, cell metadata, cell segmentation polygon coordinates downloaded Nanostring website CSV files read R data frames. gene count matrix converted sparse matrix. cell metadata contains centroid coordinates cells. cell polygon data frames converted sf data frame df2sf() function SpatialFeatureExperiment (SFE). used construct SFE object. Cell segmentation available one z-plane. first biological replicate included SFEData package. biological replicate 980 features 100,290 cells. Take look cells space: single cell resolution, lot details can seen, although ’s artifact borders fields view (FOVs). Plot cell density","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(scater) # devel version of plotExpression library(scran) library(bluster) library(ggplot2) library(patchwork) library(stringr) library(spdep) library(BiocParallel) library(BiocSingular) theme_set(theme_void()) (sfe <- HeNSCLCData()) ggplot(cellSeg(sfe)) + geom_sf(size = 0.1) +     theme_bw() +     scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) plotCellBin2D(sfe) + theme_bw()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"cells","dir":"Articles","previous_headings":"Quality control (QC)","what":"Cells","title":"CosMX non-small cell lung cancer data","text":"Single cell RNA-seq (scRNA-seq) technologies typically don’t quantify cell morphology, gene expression Visium doesn’t single cell resolution. single cell resolution smFISH based data, cell gene expression related QC metrics total number transcripts detected number genes detected, also cell morphology area (z-plane segmentation polygons provided) aspect ratio. Area relevant QC since can flag falsely undersegmented cells, .e. several cells falsely considered one cell segmentation program. However, since pre-defined gene panel used mitochondrially encoded genes quantified, scRNA-seq QC metric proportion mitochondrially encoded counts applicable. QC metrics precomputed stored colData Cell area, aspect ratio, marker stain intensities, .e. columns “sample_id” come Nanostring’s website. sf package can compute areas cell polygons. R, EBImage package can compute morphological metrics aspect ratio, eccentricity, orientation, etc., requires data converted raster. OpenCV can compute morphological metrics polygons without converting raster, needs called Python C++. Since math behind many basic morphological metrics pretty simple, may add Voyager future version. Since plotting 100,000 polygons slow plot isn’t large enough us see polygons anyway, use scattermore rasterize plot speed plotting. Instead plotting every single point, now ggplot merely displays rasterized image. Number transcript spots detected per cell make nCounts nGenes comparable across datasets, divide number genes probed. dataset, 960 genes, 20 negative controls. However, different genes may probed different datasets, can different tissues, make nCounts nGenes completely comparable across datasets. However, may still somewhat comparable, since genes highly expressed major cell types tissue tend selected gene panel. means cells mostly less 1 transcript count per gene average, surprising since cells express genes. cells detected express less 30% genes probed. Number genes (980) detected per cell Based spatial plot, seems nCounts nGenes biologically relevant, cells transcripts detected. nCounts relates nGenes ’s nature cells without transcripts? cells without transcripts central cavity. “empty” cells tend smaller cells also really large ones. Cell area distribution Larger cells likely found certain areas tissue. biological, -segmentation likely cell type tissue region. area relate total counts? may vaguely seem cells total counts tend larger (least z-plane), cells large low total counts. Negative control probes used dataset QC. calculate proportion transcripts attributed negative controls. NA’s empty cells, proportion low except outliers. prop_neg relate nCounts? looks kind like proportion mitochondrial counts vs. nCounts plot scRNA-seq, cells fewer total counts tend higher proportion mitochondrial counts. distribution obviously bimodal, since x-axis log transformed better visualize distribution, 0’s removed. ’s kind arbitrary; now ’ll remove cells 10% transcripts negative controls. removing low quality cells, 100,095 cells left.","code":"names(colData(sfe)) # Function to plot violin plot for distribution and spatial at once plot_violin_spatial <- function(sfe, feature) {     violin <- plotColData(sfe, feature, point_fun = function(...) list())     spatial <- plotSpatialFeature(sfe, feature, colGeometryName = \"centroids\",                                   scattermore = TRUE)     violin + spatial +         plot_layout(widths = c(1, 2)) } plot_violin_spatial(sfe, \"nCounts\") summary(sfe$nCounts) n_panel <- 960 colData(sfe)$nCounts_normed <- sfe$nCounts/n_panel colData(sfe)$nGenes_normed <- sfe$nGenes/n_panel plotColDataHistogram(sfe, c(\"nCounts_normed\", \"nGenes_normed\")) +     theme_bw() plot_violin_spatial(sfe, \"nGenes\") summary(sfe$nGenes) plotColDataBin2D(sfe, \"nCounts\", \"nGenes\") +     theme_bw() colData(sfe)$is_empty <- colData(sfe)$nCounts < 1 plotSpatialFeature(sfe, \"is_empty\", \"cellSeg\") plotColData(sfe, x = \"Area\", y = \"is_empty\") plot_violin_spatial(sfe, \"Area\") plotColDataBin2D(sfe, \"nCounts\", \"Area\") + theme_bw() neg_inds <- str_detect(rownames(sfe), \"^NegPrb\") # Number of negative control probes sum(neg_inds) colData(sfe)$prop_neg <- colSums(counts(sfe)[neg_inds,])/colData(sfe)$nCounts plot_violin_spatial(sfe, \"prop_neg\") plotColDataBin2D(sfe, \"nCounts\", \"prop_neg\") +     scale_fill_viridis_c() + theme_bw() # The zeros are removed plotColDataHistogram(sfe, \"prop_neg\") +     scale_x_log10() +     theme_bw() # Remove low quality cells (sfe <- sfe[,!sfe$is_empty & sfe$prop_neg < 0.1])"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"markers","dir":"Articles","previous_headings":"Quality control (QC) > Cells","what":"Markers","title":"CosMX non-small cell lung cancer data","text":"Nanostring provides cell stain marker intensities cell metadata. plot aspect ratio mean intensity cells stains markers, plotted . PanCK marker epithelial cells. CD45 leukocyte marker. CD3 T cell marker. Since takes quite plot 100,000 cells 6 times, scattermore really helps.","code":"names(colData(sfe)) plotSpatialFeature(sfe, c(\"AspectRatio\", \"Mean.DAPI\", \"Mean.MembraneStain\",                            \"Mean.PanCK\", \"Mean.CD45\", \"Mean.CD3\"),                    colGeometryName = \"centroids\", ncol = 2, scattermore = TRUE)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"genes","dir":"Articles","previous_headings":"Quality control (QC)","what":"Genes","title":"CosMX non-small cell lung cancer data","text":"red line \\(y = x\\) expected Poisson data. Gene expression dataset variance expected Poisson, even gene lower expression. Zoom negative controls Among “high quality” cells, negative controls still higher variance relative mean compared Poisson. Negative controls vs. real genes negative controls lower mean “expression” vast majority real genes.","code":"rowData(sfe)$means <- rowMeans(counts(sfe)) rowData(sfe)$vars <- rowVars(counts(sfe)) rowData(sfe)$is_neg <- neg_inds plotRowDataBin2D(sfe, \"means\", \"vars\", subset = \"is_neg\", bins = 50) +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() +     theme_bw() as.data.frame(rowData(sfe)[neg_inds,]) |>      ggplot(aes(means, vars)) +     geom_point() +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() +     theme_bw() plotRowData(sfe, x = \"means\", y = \"is_neg\") +     scale_y_log10() +     annotation_logticks(sides = \"b\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"spatial-autocorrelation-in-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation in QC metrics","title":"CosMX non-small cell lung cancer data","text":"spatial neighborhood graph required spatial dependence analyses spdep. Without benchmark, don’t yet know type neighborhood graph best purpose. Methods find spatial neighborhood graphs spdep knearneigh(), dnearneigh(), poly2nb() (polygon data contiguity relevant) recommended larger datasets. Delaunay triangulation deldir package, used spdep (tri2nb()), takes 4 5 minutes dataset size, runtime increases much drastically linearly number cells increases. Sphere Interest (SOI) graph (soi.graph()) prunes edges triangulation long, take long . triangulation SOI graph, slower knearneigh(), dnearneigh(), poly2nb(), somewhat practical considerations. implementation gabrielneigh() relativeneigh() take impracticably long (hour terminated R session impatience) dataset recommended. Methods find approximate nearest neighbors Annoy (AnnoyParam()) HNSW (HnswParam()), supported bluster BiocNeighbors packages might speed finding graphs, haven’t formally benchmarked . See Chapter 14 Spatial Data Science proximity areal data detailed discussion different neighborhood graphs spdep. methods areal data first wrapped Voyager much spatial transcriptomics data analogous areal geospatial data, data several cells aggregated areas, happens Visium spots. Just like geospatial areal data, Visium aggregation areas arbitrary represent underlying spatial process. Although sometimes geographical areal units arbitrary, tissues generally hexagonal grids means Visium spot polygons arbitrary context. Regions interest (ROI) selection spatial transcriptomics methods, laser capture microdissection (LCM) GeoMX DSP obviously analogous geospatial areal data. aggregation also happens analyze smFISH-based data cell level, basic unit observation individual transcript spots. spdep caters areal data, gstat caters geostatistical data, continuous spatial process sampled point locations. ways, spatial transcriptomics data analogous geostatistical data. Visium samples supposed spatial biological process regular hexagonal grid, pretend Visium spots points. smFISH-based single cell resolution data, cells observed can thought sample underlying spatial biological process supervening specific locations cells. sense, cells samples, since smFISH based technologies attempt visualize cells tissue section. However, biological function tissue depend particular spatial arrangement individual cells (.e. supervenes particular spatial arrangement), cell types, specific cell locations observed can thought samples process, consider cell basic unit spatial process. next release Voyager, plan add semivariograms (gstat package) exploratory tool identify presence spatial autocorrelation, length scale, anisotropy (.e. different different directions). Covariates can specified computing variogram account spatial trends adjust another spatial variable. However, unlike Morans’s , semivariogram can’t identify negative spatial autocorrelation, although since spatial neighborhood graph typically encode spatial directions, spdep autocorrelation metrics can’t identify anisotropy. Single cell smFISH based data also dissimiliar areal geostatistical data important ways. geospatial areal data, data numerous basic units spatial process (e.g. people epidemiology) aggregated areas (e.g. cities), whereas histological space, cell arguably sensible basic unit biological spatial process individual mRNA molecules. Unlike geostatistical data, cells seen tissue section often polygons tessellating tissue section rather points. Furthermore, ideally samples underlying spatial process affect spatial process geostatistical data, cells play active roles biological spatial process. However, data analysis methods areal geostatistical data can still relevant EDA descriptive models (causal mechanistic) single cell smFISH data. Different types spatial neighborhood graphs cells may relevant different processes. instance, contiguity cell segmentation polygons relevant contact involved cell signaling, although cell segmentation imperfect. Positive spatial autocorrelation can arise contact activation, negative autocorrelation can arise contact inhibition. However, cells may also influenced longer range factors secreted ligands, morphogens, simpler spatial trends like distance artery vein. case, perhaps semivariogram using Euclidean distance cells spatial weights spatial autocorrelation metrics relevant EDA. interesting compare results different spatial neighborhood graphs spatial weights, spdep gstat. Perhaps one best method, different methods reveal different phenomena. Spatial autocorrelation metrics seek measure nearby things tend similar dissimilar, neighborhood graph edge weights define mean “nearby” areal data. Note Visium spot can contain several dozens cells, spatial neighborhood graphs Visium spots describe neighborhood relationships much longer length scales spatial neighborhood graphs single cells, spatial autocorrelation metrics using Visium graph different meanings cellular neighborhood graphs. now, just demonstrate software usage, use k nearest neighborhood graph distance based edge weights, commonly done graph based clustering scRNA-seq, although don’t yet know best value k scenario. purpose vignette, say use \\(k = 5\\), execution time isn’t outrageous. argument style = \"W\" row normalize adjacency matrix spatial neighborhood graph necessary Moran scatter plot. tissue, many cells appear contiguous, since cell segmentation imperfect, many false singletons, makes polygon contiguity neighbors poly2nb() problematic without modification. based distribution number neighbors based contiguity, \\(k = 5\\) doesn’t seem bad approximate contiguity. Now compute Moran’s cell QC metrics Positive spatial autocorrelation suggested, stronger nCounts nGenes. length scales spatial autocorrelation QC metrics? nice lagged neighborhood graphs can stored reused features rather recomputed feature spdep::sp.correlogram() called behind scene . takes minutes run, long typical song. Another way find length scale spatial autocorrelation bin cells bins different sizes find spatial autocorrelation bin size, probably faster finding lagged values higher higher neighborhoods since geom_bin2d() geom_hex() ggplot2 run pretty fast even large datasets. use semivariogram; gstat also bins data estimating semivariogram calculating semivariogram long distance much faster correlogram cell-cell neighborhood graphs. Note MulticoreParam() doesn’t work Windows; vignette built Linux. Use SnowParam() DoparParam() Windows. See ?BiocParallelParam available parallel processing backends. notice significant performance differences ShowParam() MulticoreParam() context. seem similar length scales, aspect ratios tend decay quickly. Moran’s scatter plot nCounts. first panel, density points plot, second, points influential fitting line highlighted red, still 2D histogram avoid overplotting. obvious clusters plot clusters may obscured overplotting. Local Moran’s nCounts Cool, appears epithelial regions tend homogenous nCounts.","code":"system.time(     colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                   dist_type = \"idw\", k = 5,                                                    style = \"W\")     ) features_use <- c(\"nCounts\", \"nGenes\", \"Area\", \"AspectRatio\") sfe <- colDataMoransI(sfe, features_use, colGraphName = \"knn5\") colFeatureData(sfe)[features_use,] system.time(     sfe <- colDataUnivariate(sfe, \"sp.correlogram\", features = features_use,                          colGraphName = \"knn5\", order = 6, zero.policy = TRUE,                          BPPARAM = MulticoreParam(2)) ) plotCorrelogram(sfe, features_use) +     theme_bw() sfe <- colDataUnivariate(sfe, \"moran.plot\", \"nCounts\", colGraphName = \"knn5\") p1 <- moranPlot(sfe, \"nCounts\", binned = TRUE, plot_influential = FALSE) p2 <- moranPlot(sfe, \"nCounts\", binned = TRUE) p1 / p2 + plot_layout(guides = \"collect\") & theme_bw() sfe <- colDataUnivariate(sfe, \"localmoran\", \"nCounts\", colGraphName = \"knn5\") plotLocalResult(sfe, \"localmoran\", \"nCounts\", colGeometryName = \"cellSeg\",                 divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"data-normalization","dir":"Articles","previous_headings":"","what":"Data normalization","title":"CosMX non-small cell lung cancer data","text":"Given may relationship cell size total counts, total counts may biological thus purely treated technical, questions raised data normalization different standard scRNA-seq practices. instance, technical contributions total counts kind data? Furthermore, cell area, since part technical, z-plane cell segmentation polygons intersects cell, cell types, biological? Also, different methods data normalization affect spatial autocorrelation? spatial autocorrelation used ways normalizing data? Besides correcting technical effects making gene expression cells different total counts comparable, data normalization stabilizes variance tries make data normally distributed since many statistical methods assume normally distributed data. don’t know best practice normalize kind data, still normalize data downstream analyses.","code":"sfe <- logNormCounts(sfe)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moran’s I","title":"CosMX non-small cell lung cancer data","text":"run global Moran’s log normalized gene expression. real genes tend spatial autocorrelation negative controls? seems least shorter length scale captured k nearest neighbor graph, genes don’t strong spatial autocorrelation strong positive spatial autocorrelation. contrast, Moran’s negative controls closely packed around 0, indicating lack spatial autocorrelation, good sign, evidence technical artifact manifests spatial trend manifest negative controls. genes highest Moran’s ? highlight epithelial regions. regions spatially organized, short length scale used Moran’s correlogram shows Moran’s decays first order neighbors. wonder using longer length scale change results.","code":"# Note: on your computer, you can put progressbar = TRUE inside MulticoreParam() # to show progress bar. This applies to any BiocParallParam. sfe <- runMoransI(sfe, features = rownames(sfe),                    BPPARAM = MulticoreParam(2)) plotRowData(sfe, x = \"moran_sample01\", y = \"is_neg\") +     geom_hline(yintercept = 0, linetype = 2) top_moran <- rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)[1:6]] plotSpatialFeature(sfe, top_moran, colGeometryName = \"centroids\",                     scattermore = TRUE, ncol = 2)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"non-spatial-dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Non-spatial dimension reduction and clustering","title":"CosMX non-small cell lung cancer data","text":"first PC highlights epithelium. PC2 highlights T cells. PC4 might highlight leukocytes. Need check genes highest loadings find PCs mean. Non-spatial clustering locating clusters space analyses can done stage: many cell types neighborhood cell? subject different definitions neighborhood. cell types tend co-localize ? Find spatial regions based cell type colocalization, can done R package spicyR (Canete et al. 2022)","code":"set.seed(29) sfe <- runPCA(sfe, ncomponents = 30, scale = TRUE, BSPARAM = IrlbaParam()) ElbowPlot(sfe, ndims = 30) + theme_bw() plotDimLoadings(sfe, dims = 1:6) + theme_bw() spatialReducedDim(sfe, \"PCA\", 6, colGeometryName = \"centroids\", divergent = TRUE,                   diverge_center = 0, ncol = 2, scattermore = TRUE) set.seed(29) sfe <- runUMAP(sfe, dimred = \"PCA\", n_dimred = 15) colData(sfe)$cluster <- clusterRows(reducedDim(sfe, \"PCA\")[,1:15],                                     BLUSPARAM = SNNGraphParam(                                         cluster.fun = \"leiden\",                                         cluster.args = list(                                             resolution_parameter = 0.5,                                             objective_function = \"modularity\"))) plotPCA(sfe, ncomponents = 4, colour_by = \"cluster\") +     geom_density2d() plotUMAP(sfe, colour_by = \"cluster\") plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"cellSeg\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"differential-expression","dir":"Articles","previous_headings":"","what":"Differential expression","title":"CosMX non-small cell lung cancer data","text":"Cluster marker genes found Wilcoxon rank sum test commonly done scRNA-seq. ’s already sorted p-values Get significant marker cluster plot. Since ’re many points, used development version scater plot points, uninformative due overplotting make plot really slow. Plot top marker genes heatmap","code":"markers <- findMarkers(sfe, groups = colData(sfe)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[6]] genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe, genes_use, x = \"cluster\", point_fun = function(...) list()) genes_use2 <- unique(unlist(lapply(markers, function(x) rownames(x)[1:5]))) plotGroupedHeatmap(sfe, genes_use2, group = \"cluster\", colour = scales::viridis_pal()(100))"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"local-spatial-statistics-of-marker-genes","dir":"Articles","previous_headings":"","what":"Local spatial statistics of marker genes","title":"CosMX non-small cell lung cancer data","text":"Plot genes space Moran’s marker genes Local Moran’s marker genes seems histological regions tend spatially homogenous gene expression others. epithelial region tends homogenous. Run local spatial heteroscdasticity (LOSH) marker genes find local heterogeneity genes heterogeneous also highly expressed, COLA1 IGKC. However case genes. example, MZT2A quite ubiqiutously experssed, heterogeneous regions others, KRT19 seem much heterogeneous ’s highly expressed. MZT2A, LOSH picked artifact edges FOVs, although apparent genes plotted . don’t information cell belongs FOV, FOV edge effects considered data normalization. interesting systematically see LOSH relates gene expression across genes, differs cell types gene functions.","code":"plotSpatialFeature(sfe, genes_use, colGeometryName = \"centroids\", ncol = 2,                    scattermore = TRUE) rowData(sfe)[genes_use, \"moran_sample01\", drop = FALSE] sfe <- runUnivariate(sfe, \"localmoran\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, type = \"localmoran\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 2, divergent = TRUE,                 diverge_center = 0, scattermore = TRUE) sfe <- runUnivariate(sfe, \"LOSH\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, type = \"LOSH\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 2, scattermore = TRUE)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"CosMX non-small cell lung cancer data","text":"","code":"sessionInfo()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Xenium breast cancer dataset","text":"Xenium new technology 10X genomics single cell resolution smFISH based spatial transcriptomics. first Xenium dataset formalin fixed paraffin embedded (FFPE) human breast tumor, reported (Janesick et al. 2022) downloaded 10X website. might representative Xenium data formal release late 2022. gene count matrix downloaded HDF5 file read R SingleCellExperiment (SCE) object DropletUtils::read10xCounts(). cell metadata (including centroid coordinates) cell segmentation polygons downloaded parquet files, compact way store columnar data CSV, read R data frames arrow::read_parquet(). cell polygons converted sf data frame SpatialFeatureExperiment::df2sf(). SCE object converted SpatialFeatureExperiment (SFE) polygon geometry added SFE object, SFEData package. load packages used vignette. 118708 cells dataset, little CosMX dataset. SFE object doesn’t column names (.e. cell IDs). assign cell IDs. tissue, cell outlines, looks like  Plot cell density space","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) #> Loading required package: SummarizedExperiment #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: 'MatrixGenerics' #> The following objects are masked from 'package:matrixStats': #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: 'BiocGenerics' #> The following objects are masked from 'package:stats': #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from 'package:base': #>  #>     anyDuplicated, aperm, append, as.data.frame, basename, cbind, #>     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, #>     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, #>     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, #>     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, #>     table, tapply, union, unique, unsplit, which.max, which.min #> Loading required package: S4Vectors #>  #> Attaching package: 'S4Vectors' #> The following objects are masked from 'package:base': #>  #>     expand.grid, I, unname #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: 'Biobase' #> The following object is masked from 'package:MatrixGenerics': #>  #>     rowMedians #> The following objects are masked from 'package:matrixStats': #>  #>     anyMissing, rowMedians library(SpatialExperiment) library(ggplot2) library(stringr) library(scater) # devel version of plotExpression #> Loading required package: scuttle library(scuttle) library(tidyselect) library(BiocParallel) library(BiocSingular) library(bluster) library(scran) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following object is masked from 'package:Biobase': #>  #>     combine #> The following objects are masked from 'package:GenomicRanges': #>  #>     intersect, setdiff, union #> The following object is masked from 'package:GenomeInfoDb': #>  #>     intersect #> The following objects are masked from 'package:IRanges': #>  #>     collapse, desc, intersect, setdiff, slice, union #> The following objects are masked from 'package:S4Vectors': #>  #>     first, intersect, rename, setdiff, setequal, union #> The following objects are masked from 'package:BiocGenerics': #>  #>     combine, intersect, setdiff, union #> The following object is masked from 'package:matrixStats': #>  #>     count #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(tidyr) #>  #> Attaching package: 'tidyr' #> The following object is masked from 'package:S4Vectors': #>  #>     expand library(patchwork) theme_set(theme_void()) (sfe <- JanesickBreastData(dataset = \"rep2\")) #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> require(\"SpatialFeatureExperiment\") #> class: SpatialFeatureExperiment  #> dim: 541 118708  #> metadata(1): Samples #> assays(1): counts #> rownames(541): ABCC11 ACTA2 ... BLANK_0497 BLANK_0499 #> rowData names(6): ID Symbol ... vars cv2 #> colnames: NULL #> colData names(10): Sample Barcode ... nCounts nGenes #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_centroid y_centroid #> imgData names(1): sample_id #>  #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON), nucSeg (GEOMETRY)  #>  #> Graphs: #> sample01: colnames(sfe) <- seq_len(ncol(sfe)) ggplot(cellSeg(sfe)) + geom_sf(size = 0.1) +     theme_bw() +     scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) plotCellBin2D(sfe) + theme_bw()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"cells","dir":"Articles","previous_headings":"Quality control","what":"Cells","title":"Xenium breast cancer dataset","text":"QC metrics precomputed stored colData Since ’re cells, better plot tissue larger, ’ll plot histogram QC metrics spatial plots separately, unlike CosMx vignette. divided nCounts total number genes probed, histogram comparable smFISH-based datasets.  Compared FFPE CosMX non-small cell lung cancer dataset, transcripts per gene average larger proportion genes detected dataset, also FFPE. However, interpreted care, since two datasets different tissues different gene panels, may may indicate Xenium better detection efficiency CosMX. wonder regular notches nGenes histogram .  seems FOV artifacts. However, cell ID FOV information unavailable.  nCounts relate nGenes?  appear two branches. wonder ’re related sparse vs. dense regions. probably . plot distribution cell area  ’s pixels. ’s long tail. nuclei much smaller cells. cell area distributed space?  Cells sparse region tend larger dense region. may biological artifact cell segmentation algorithm . nuclei segmentations plotted instead cell segmentation. nuclei much smaller ’re kind hard see.  ’s outlier near right edge section, throwing dynamic range plot. Upon inspection H&E image, outlier bit tissue debris doesn’t look like cell. can still cells dense, gland like regions tend larger nuclei. may biological, nuclei densely packed regions likely undersegmented, .e. multiple nuclei counted one nuclei segmentation program, . cell area relate nuclei area?  , two branches, probably related cell density cell type. nucleus outlier also large cell area, though much outlier cell area. However, spatial outlier ’s unusually large compared neighbors (scroll two plots back). proportion cell z-plane taken nucleus? calculate proportion plot distribution.  distribution generated two peaks added . histogram, seems cells without nuclei segmentation artifacts nucleus larger cell. However, since many cells dataset just cells visible histogram, double check: cells without nuclei nuclei larger cells. plot nuclei proportion space:  Cells histological regions larger proportions occupied nuclei. interesting see, controlling cell type, cell area, nucleus area, proportion cell occupied nucleus relate gene expression. However, problem cell segmentation available one z-plane areas also relate z-plane intersects cell. proportion cell area occupied nucleus relate cell area? plot 2D histogram better show density point plot avoid overplotting.  Smaller cells tend higher proportion occupied nucleus. can related cell type, limitation small nuclei can tissue. nucleus area relate proportion cell occupied nucleus?  place outlier obvious. cells small nuclei low proportion area occupied nucleus.","code":"names(colData(sfe)) #>  [1] \"Sample\"                  \"Barcode\"                 #>  [3] \"transcript_counts\"       \"control_probe_counts\"    #>  [5] \"control_codeword_counts\" \"cell_area\"               #>  [7] \"nucleus_area\"            \"sample_id\"               #>  [9] \"nCounts\"                 \"nGenes\" n_panel <- 313 colData(sfe)$nCounts_normed <- sfe$nCounts/n_panel colData(sfe)$nGenes_normed <- sfe$nGenes/n_panel plotColDataHistogram(sfe, c(\"nCounts_normed\", \"nGenes_normed\")) + theme_bw() plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"cellSeg\") plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"cellSeg\") plotColDataBin2D(sfe, \"nCounts\", \"nGenes\") + theme_bw() plotColDataHistogram(sfe, c(\"cell_area\", \"nucleus_area\"), scales = \"free_y\") +     theme_bw() plotSpatialFeature(sfe, \"cell_area\", colGeometryName = \"cellSeg\") plotSpatialFeature(sfe, \"nucleus_area\", colGeometryName = \"nucSeg\") plotColDataBin2D(sfe, \"cell_area\", \"nucleus_area\") + theme_bw() +     scale_fill_viridis_c() #> Scale for 'fill' is already present. Adding another scale for 'fill', which #> will replace the existing scale. colData(sfe)$prop_nuc <- sfe$nucleus_area / sfe$cell_area plotColDataHistogram(sfe, \"prop_nuc\") + theme_bw() # No nucleus sum(sfe$nucleus_area < 1) #> [1] 0 # Nucleus larger than cell sum(sfe$nucleus_area > sfe$cell_area) #> [1] 0 plotSpatialFeature(sfe, \"prop_nuc\", colGeometryName = \"cellSeg\") plotColDataBin2D(sfe, \"cell_area\", \"prop_nuc\") + theme_bw() +     scale_fill_viridis_c() #> Scale for 'fill' is already present. Adding another scale for 'fill', which #> will replace the existing scale. plotColDataBin2D(sfe, \"nucleus_area\", \"prop_nuc\") + theme_bw() +     scale_fill_viridis_c() #> Scale for 'fill' is already present. Adding another scale for 'fill', which #> will replace the existing scale. knitr::opts_chunk$set(eval = FALSE)"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"negative-controls","dir":"Articles","previous_headings":"Quality control","what":"Negative controls","title":"Xenium breast cancer dataset","text":"Since hundred genes plus negative control probes, row names SFE object can printed find negative control probes called. According Xenium paper (Janesick et al. 2022), 3 types controls: probe controls assess non-specific binding RNA, decoding controls assess misassigned genes, genomic DNA (gDNA) controls ensure signal RNA. paper explain detail control probes designed, explain blank probes . blank probes can used negative control. number 1, probe control number 2, decoding control must number 3, gDNA control Also make indicator whether feature sort negative control addPerCellQCMetrics() function scuttle package can conveniently add transcript counts, proportion total counts, number features detected subset features SCE object. SFE object, SFE inherits SCE. plot proportion transcript counts coming negative control. first, use Tidyverse reshape percentage columns different types negative controls long form plot different panels plot. histogram dominated bin 0 extreme outliers seen evident scale x axis. also plot histogram cells least 1 count negative control. NA’s come cells got segmented transcripts detected. vast majority cells less 1% transcript counts negative controls, outliers 50%. plot distribution number negative control counts per cell: counts low, mostly 0, outliers 10 counts types aggregated. outlier 50% counts negative controls must low total real transcript counts begin . scuttle package can detect outliers, default says anything 0 outlier, since 3 median absolute deviations (MADs) away median, 0, MAD 0 since vast majority cells don’t negative control count. makes sense allow small proportion negative controls. use distribution just cells least 1 negative control count find outliers. distribution long tail definite outliers. get outliers, based cells least 1 negative control count See outliers located space ’re kind hard see. wonder tend smaller. seem smaller. Outliers negative probe control negative codeword control also hard see plot, plots skipped . top left region tissue tends counts antisense controls. Now identified outliers. remove outliers empty cells proceeding analyses. 1000 cells removed. many negative control features detected per cell? 3 count per cell per type. Hence rays matrix plot. non-outliers, type around 1%, data looks like really good.","code":"rownames(sfe) is_blank <- str_detect(rownames(sfe), \"^BLANK_\") sum(is_blank) is_neg <- str_detect(rownames(sfe), \"^NegControlProbe\") sum(is_neg) is_neg2 <- str_detect(rownames(sfe), \"^NegControlCodeword\") sum(is_neg2) is_anti <- str_detect(rownames(sfe), \"^antisense\") sum(is_anti) is_any_neg <- is_blank | is_neg | is_neg2 | is_anti sfe <- addPerCellQCMetrics(sfe, subsets = list(blank = is_blank,                                                negProbe = is_neg,                                                negCodeword = is_neg2,                                                anti = is_anti,                                                any_neg = is_any_neg)) names(colData(sfe)) cols_use <- names(colData(sfe))[str_detect(names(colData(sfe)), \"_percent$\")] plotColDataHistogram(sfe, cols_use, bins = 100, ncol = 3) + theme_bw() plotColDataHistogram(sfe, cols_use, bins = 100, ncol = 3) +      scale_x_log10() +     annotation_logticks(sides = \"b\") +     theme_bw() cols_use2 <- names(colData(sfe))[str_detect(names(colData(sfe)), \"_detected$\")] plotColDataHistogram(sfe, cols_use2, bins = 20, ncol = 3) +     # Avoid decimal breaks on x axis unless there're too few breaks     scale_x_continuous(breaks = scales::breaks_extended(Q = c(1,2,5))) +     theme_bw() get_neg_ctrl_outliers <- function(col, sfe) {     inds <- colData(sfe)$nCounts > 0 & colData(sfe)[[col]] > 0     df <- colData(sfe)[inds,]     outlier_inds <- isOutlier(df[[col]], type = \"higher\")     outliers <- rownames(df)[outlier_inds]     col2 <- str_remove(col, \"^subsets_\")     col2 <- str_remove(col2, \"_percent$\")     new_colname <- paste(\"is\", col2, \"outlier\", sep = \"_\")     colData(sfe)[[new_colname]] <- colnames(sfe) %in% outliers     sfe } cols_use <- names(colData(sfe))[str_detect(names(colData(sfe)), \"_percent$\")] for (n in cols_use) {     sfe <- get_neg_ctrl_outliers(n, sfe) } names(colData(sfe)) plotSpatialFeature(sfe, \"is_blank_outlier\", colGeometryName = \"cellSeg\") plotColData(sfe, y = \"is_blank_outlier\", x = \"cell_area\",              # to not to plot points, only in devel version of scater             point_fun = function(...) list()) plotSpatialFeature(sfe, \"is_anti_outlier\", colGeometryName = \"cellSeg\") inds_keep <- sfe$nCounts > 0 & sfe$nucleus_area < 400 & !sfe$is_anti_outlier &     !sfe$is_blank_outlier & !sfe$is_negCodeword_outlier & !sfe$is_negProbe_outlier (sfe <- sfe[,inds_keep]) plotColDataHistogram(sfe, cols_use2, bins = 20, ncol = 3) +     # Avoid decimal breaks on x axis unless there're too few breaks     scale_x_continuous(breaks = scales::breaks_extended(3, Q = c(1,2,5))) +     theme_bw()"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"genes","dir":"Articles","previous_headings":"Quality control","what":"Genes","title":"Xenium breast cancer dataset","text":"look mean variance gene Real genes generally higher mean expression across cells negative controls. real genes negative controls plotted different colors red line \\(y = x\\) expected data follows Poisson distribution. Negative controls real genes form mostly separate clusters. Negative controls stick close line, real genes overdispersed. Unlike CosMX dataset, negative controls don’t seem overdispersed.","code":"rowData(sfe)$means <- rowMeans(counts(sfe)) rowData(sfe)$vars <- rowVars(counts(sfe)) rowData(sfe)$is_neg <- is_any_neg plotRowData(sfe, x = \"means\", y = \"is_neg\") +     scale_y_log10() +     annotation_logticks(sides = \"b\") plotRowDataBin2D(sfe, \"means\", \"vars\", subset = \"is_neg\",                   name_true = \"Counts (negative controls)\",                   name_false = \"Counts (real genes)\", bins = 50) +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() +     theme_bw()"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"spatial-autocorrelation-of-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation of QC metrics","title":"Xenium breast cancer dataset","text":"’s sparse dense region. kind neighborhood graph shall use? “neighbor” mean ? cells sparse region just singletons? ’s length scale influence? might depends cell type contact secreted signals used cell type, length scale influence. k nearest neighbors used, neighbors dense region much closer together sparse region. distance based neighbors used, cells dense region neighbors cells sparse region, sparse region can break multiple compartments distance cutoff long enough. purpose demonstration, use k nearest neighbors \\(k = 5\\), inverse distance weighting. neighbors lead longer computation time spatial autocorrelation metrics. Global Moran’s indicate positive spatial autocorrelation. strength spatial autocorrelation can vary spatially, also run local Moran’s . pointsize argument adjusts point size scattermore. default 0, meaning single pixels, since cells sparse region hard see way, increase pointsize. still plot polygons larger single panel plots, use scattermore multi-panel plots polygons panel invisible anyway due small size save time. Interestingly, nCounts homogenous interior dense region, nGenes homogenous edge dense region. expected, cell area homogenous sparse region. However, nucleus area homogenous interior dense region. Moran plot nCounts obvious clusters . lower panel, 2D histogram influential points plotted red.","code":"system.time(     colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                    dist_type = \"idw\", k = 5,                                                    style = \"W\") ) sfe <- colDataMoransI(sfe, c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                       colGraphName = \"knn5\") colFeatureData(sfe)[c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),] sfe <- colDataUnivariate(sfe, type = \"localmoran\",                           features = c(\"nCounts\", \"nGenes\", \"cell_area\",                                        \"nucleus_area\"),                          colGraphName = \"knn5\", BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, \"localmoran\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"centroids\", scattermore = TRUE,                 divergent = TRUE, diverge_center = 0, pointsize = 1) sfe <- colDataUnivariate(sfe, \"moran.plot\", \"nCounts\", colGraphName = \"knn5\") p1 <- moranPlot(sfe, \"nCounts\", binned = TRUE, plot_influential = FALSE)  p2 <- moranPlot(sfe, \"nCounts\", binned = TRUE) p1 / p2 + plot_layout(guides = \"collect\") & theme_bw()"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moran’s I","title":"Xenium breast cancer dataset","text":"default, gene experssion, log normalized counts used spatial autocorrelation metrics, running Moran’s , normalize data. Somehow thre’re fewer genes dataset compared CosMX dataset many cells, running Moran’s genes took much longer. Use cores available speed . expected, generally negative controls tightly clustered around 0, real genes positive Moran’s , means generally technical artifact spatial trend. significantly negative Moran’s observed. negative spatial autocorrelation rare gene expression? two negative controls sizable Moran’s ? somewhat spatial trend antisense probe, detected upper left. However, might significantly affect results since 2 counts 1% counts cell. negative control codeword 1 count per cell cells negative control detected seem far . detected negative controls, detected one also one highest Moran’s among negative controls. However, negative control higher Moran’s among detected. genes highest Moran’s ? highlight histological regions, CosMX vignette. Moran’s relate gene expression level? highly expressed genes higher Moran’s , less expressed genes higher Moran’s well.","code":"sfe <- logNormCounts(sfe) system.time(     sfe <- runMoransI(sfe, colGraphName = \"knn5\", BPPARAM = MulticoreParam(2)) ) rowData(sfe)$is_neg <- is_any_neg plotRowData(sfe, x = \"moran_sample01\", y = \"is_neg\") ord <- order(rowData(sfe)$moran_sample01[is_any_neg], decreasing = TRUE)[1:2] top_neg <- rownames(sfe)[is_any_neg][ord] plotSpatialFeature(sfe, top_neg, colGeometryName = \"centroids\",                    scattermore = TRUE, pointsize = 1) head(sort(rowData(sfe)$means[is_any_neg], decreasing = TRUE), 15) top_moran <- rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)[1:6]] plotSpatialFeature(sfe, top_moran, colGeometryName = \"centroids\",                    scattermore = TRUE, ncol = 2, pointsize = 0.5) plotRowData(sfe, x = \"means\", y = \"moran_sample01\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"non-spatial-dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Non-spatial dimension reduction and clustering","title":"Xenium breast cancer dataset","text":"run non-spatial PCA scRNA-seq data spatial region explicitly used, PC’s highlight spatial regions due spatial autocorrelation gene expression histological regions different cell types. Non-spatial clustering locating clusters space Now scater can also rasterize plots lots points, different mechanism scattermore requires system dependencies. Plot location clusters space","code":"set.seed(29) sfe <- runPCA(sfe, ncomponents = 30, scale = TRUE, BSPARAM = IrlbaParam()) ElbowPlot(sfe, ndims = 30) + theme_bw() plotDimLoadings(sfe, dims = 1:6) + theme_bw() spatialReducedDim(sfe, \"PCA\", 6, colGeometryName = \"centroids\", divergent = TRUE,                   diverge_center = 0, ncol = 2, scattermore = TRUE, pointsize = 0.5) set.seed(29) sfe <- runUMAP(sfe, dimred = \"PCA\", n_dimred = 15) colData(sfe)$cluster <- clusterRows(reducedDim(sfe, \"PCA\")[,1:15],                                     BLUSPARAM = SNNGraphParam(                                         cluster.fun = \"leiden\",                                         cluster.args = list(                                             resolution_parameter = 0.5,                                             objective_function = \"modularity\"))) plotPCA(sfe, ncomponents = 4, colour_by = \"cluster\", rasterise = TRUE) +     geom_density2d() plotUMAP(sfe, colour_by = \"cluster\", rasterise = TRUE) plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"cellSeg\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"differential-expression","dir":"Articles","previous_headings":"","what":"Differential expression","title":"Xenium breast cancer dataset","text":"Cluster marker genes found Wilcoxon rank sum test commonly done scRNA-seq. ’s already sorted p-values Get significant marker cluster plot Plot top marker genes heatmap","code":"markers <- findMarkers(sfe, groups = colData(sfe)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[6]] genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe, genes_use, x = \"cluster\", point_fun = function(...) list()) genes_use2 <- unique(unlist(lapply(markers, function(x) rownames(x)[1:5]))) plotGroupedHeatmap(sfe, genes_use2, group = \"cluster\", colour = scales::viridis_pal()(100))"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"local-spatial-statistics-of-marker-genes","dir":"Articles","previous_headings":"","what":"Local spatial statistics of marker genes","title":"Xenium breast cancer dataset","text":"First plot genes space reference Global Moran’s marker genes marker genes positive spatial autocorrelation, stronger others. Local Moran’s marker genes seems histological regions tend spatially homogenous gene expression others. epithelial region tends homogenous. genes, regions higher expression also higher local Moran’s , FOXA1 GATA3, genes, case, FGL2 LUM. Run local spatial heteroscdasticity (LOSH) marker genes find local heterogeneity , just like CosMX dataset, LOSH higher gene highly expressed (e.g. CD3E, LUM, TENT5C) cases (e.g. FOXA1, GATA3). may due spatial distribution different cell types.","code":"plotSpatialFeature(sfe, genes_use, colGeometryName = \"centroids\", ncol = 3,                    pointsize = 0.3, scattermore = TRUE) setNames(rowData(sfe)[genes_use, \"moran_sample01\"], genes_use) sfe <- runUnivariate(sfe, \"localmoran\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, type = \"localmoran\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 3, divergent = TRUE,                 diverge_center = 0, scattermore = TRUE, pointsize = 0.3) sfe <- runUnivariate(sfe, \"LOSH\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, type = \"LOSH\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 3, scattermore = TRUE,                  pointsize = 0.3)"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Xenium breast cancer dataset","text":"","code":"sessionInfo()"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MERFISH mouse liver dataset and considerations of large data","text":"SpatialFeatureExperiment (SFE) Voyager packages originally developed around relatively small Visium dataset proof concept, hence originally optimized large datasets. However, larger smFISH datasets hundreds thousands, sometimes million cells, certainly coming. Among studies using smFISH-based spatial transcriptomics technologies reported number cells per dataset, number cells per dataset increased past years (Moses Pachter 2022). vignette, use MERFISH mouse liver dataset downloaded Vizgen website preview features come later versions Voyager relevant larger datasets smaller ones well. gene count matrix cell metadata (including centroid coordinates) downloaded CSV files read R. cell polygons HDF5 files, one HDF5 file per field view (FOV), ’re 1000 FOVs dataset. Converting HDF5 files sf dataframe trivial. See vignette creating SFE object code used conversion, polygons included SFE object. cell metadata already cell volume. polygons used analyses, polygons can’t seen static plot hundreds thousands cells anyway, conversion optional. load packages used 395215 cells dataset Cell density pretty homogenous shows structure denser regions seem relate blood vessels.","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(scater) # devel version of plotExpression library(scran) library(bluster) library(ggplot2) library(patchwork) library(stringr) library(spdep) library(BiocParallel) library(BiocSingular) library(gstat) library(scattermore) theme_set(theme_void()) (sfe <- VizgenLiverData()) ggplot(colGeometry(sfe, \"cellSeg\")) + geom_sf(size = 0.1) +     scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) +     theme_bw() ggplot(as.data.frame(spatialCoords(sfe))) +     geom_hex(aes(center_x, center_y), bins = 300) +     scale_fill_distiller(palette = \"Blues\", direction = 1) +     scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) +     theme_bw() + coord_equal()"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"quality-control","dir":"Articles","previous_headings":"","what":"Quality control","title":"MERFISH mouse liver dataset and considerations of large data","text":"Plotting almost 400,000 polygons kind slow doable nCounts kind looks like salt pepper. Using scattermore package can speed plotting large number points. non-interactive plot, cell polygons small see anyway, plotting cell centroid points fine. next version ov Voyager, add arguments select bounding box zoom smaller region tissue making non-interactive plots. run server, plotting almost 400,000 polygons took almost 22 seconds, using geom_scattermore() took less one second. Using geom_scattermore() plotting cell density space added next release Voyager. especially help plotting multiple genes space. However, note geom_scattermore() fast rasterizes plot, plot pixelated enlarged. Since aren’t many genes, genes negative control probes can shown number real genes 347 Plot distribution nCounts, divided number genes panel, distribution comparable across datasets different numbers genes. Also plot number genes detected per cell, geom_scattermore() Plot distribution nGenes, divided number genes panel Distribution cell volume space nCounts relate nGenes? ’re two branches. Interesting. cell size relate nCounts? , 2 branches.","code":"names(colData(sfe)) system.time(     print(plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"cellSeg\")) ) coldata_scattermore <- function(sfe, feature) {     df <- as.data.frame(spatialCoords(sfe))     df <- cbind(df, colData(sfe))     nms <- spatialCoordsNames(sfe)     ggplot(df) +         geom_scattermore(aes_string(nms[1], nms[2], color = feature)) +         scale_color_distiller(palette = \"Blues\", direction = 1) +         coord_equal() } system.time({     print(coldata_scattermore(sfe, \"nCounts\")) }) rownames(sfe) n_panel <- 347 as.data.frame(colData(sfe)) |>      ggplot(aes(nCounts/n_panel)) +     geom_histogram(bins = 100) +     theme_bw() coldata_scattermore(sfe, \"nGenes\") as.data.frame(colData(sfe)) |>      ggplot(aes(nGenes/n_panel)) +     geom_histogram(bins = 100) +     theme_bw() coldata_scattermore(sfe, \"volume\") colData(sfe) |>      as.data.frame() |>      ggplot(aes(nCounts, nGenes)) +     geom_bin2d(bins = 200) +     scale_fill_distiller(palette = \"Blues\", direction = 1) +     theme_bw() colData(sfe) |>      as.data.frame() |>      ggplot(aes(volume, nCounts)) +     geom_bin2d(bins = 200) +     scale_fill_distiller(palette = \"Blues\", direction = 1) +     theme_bw()"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"negative-controls","dir":"Articles","previous_headings":"Quality control","what":"Negative controls","title":"MERFISH mouse liver dataset and considerations of large data","text":"Total transcript counts blank probes Number blank features detected per cell Percentage oof blank features per cell percentage interesting: within tissue, cells high percentage blank counts scattered like salt pepper, cells left edge tissue, edges FOVs, tissue doesn’t end. NA’s cells without transcript detected. Also plot histogram cells least one blank count. Unlike Xenium dataset, cells least one blank count. small percentage blank counts acceptable. remove outlier based distribution percentage ’s greater 0. outliers percentage blank counts low total counts. seemingly real cells sizable nCounts also low percentage blank counts. Since distribution percentage long tail, log transform finding outliers. proportion cells outliers? ’s cutoff outlier? Remove outliers empty cells ’re still 390,000 cells left.","code":"is_blank <- str_detect(rownames(sfe), \"^Blank-\") sfe <- addPerCellQCMetrics(sfe, subset = list(blank = is_blank)) names(colData(sfe)) coldata_scattermore(sfe, \"subsets_blank_sum\") as.data.frame(colData(sfe)) |>      ggplot(aes(subsets_blank_sum)) +     geom_histogram(bins = 100) +     theme_bw() coldata_scattermore(sfe, \"subsets_blank_detected\") as.data.frame(colData(sfe)) |>      ggplot(aes(subsets_blank_detected)) +     geom_histogram(bins = 100) +     theme_bw() coldata_scattermore(sfe, \"subsets_blank_percent\") as.data.frame(colData(sfe)) |>      ggplot(aes(subsets_blank_percent)) +     geom_histogram(bins = 100) +     theme_bw() mean(sfe$subsets_blank_sum > 0) summary(sfe$subsets_blank_percent) as.data.frame(colData(sfe)[sfe$nCounts > 0 & sfe$subsets_blank_sum > 0,]) |>      ggplot(aes(subsets_blank_percent)) +     geom_histogram(bins = 100) +     theme_bw() +     scale_x_log10() +     annotation_logticks(sides = \"b\") colData(sfe) |>      as.data.frame() |>      ggplot(aes(nCounts, subsets_blank_percent)) +     geom_bin2d(bins = 200) +     scale_fill_viridis_c() +     theme_bw() get_neg_ctrl_outliers <- function(col, sfe, nmads = 3, log = FALSE) {     inds <- colData(sfe)$nCounts > 0 & colData(sfe)[[col]] > 0     df <- colData(sfe)[inds,]     outlier_inds <- isOutlier(df[[col]], type = \"higher\", nmads = nmads, log = log)     outliers <- rownames(df)[outlier_inds]     col2 <- str_remove(col, \"^subsets_\")     col2 <- str_remove(col2, \"_percent$\")     new_colname <- paste(\"is\", col2, \"outlier\", sep = \"_\")     colData(sfe)[[new_colname]] <- colnames(sfe) %in% outliers     sfe } sfe <- get_neg_ctrl_outliers(\"subsets_blank_percent\", sfe, log = TRUE) mean(sfe$is_blank_outlier) min(sfe$subsets_blank_percent[sfe$is_blank_outlier]) (sfe <- sfe[, !sfe$is_blank_outlier & sfe$nCounts > 0])"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"genes","dir":"Articles","previous_headings":"Quality control","what":"Genes","title":"MERFISH mouse liver dataset and considerations of large data","text":"look mean variance gene Real genes generally higher mean expression across cells negative controls. real genes higher mean expression blanks, ’s considerable overlap distribution, probably genes expressed lower levels fewer cells included. real genes negative controls plotted different colors red line \\(y = x\\) expected data follows Poisson distribution. Negative controls real genes form mostly separate clusters. Negative controls stick close line, real genes overdispersed. zoomed , blanks also somewhat overdispersed.","code":"rowData(sfe)$means <- rowMeans(counts(sfe)) rowData(sfe)$vars <- rowVars(counts(sfe)) rowData(sfe)$is_blank <- is_blank plotRowData(sfe, x = \"means\", y = \"is_blank\") +     scale_y_log10() +     annotation_logticks(sides = \"b\") as.data.frame(rowData(sfe)) |>      ggplot(aes(means, vars)) +     geom_bin2d(bins = 50, data = as.data.frame(rowData(sfe)[!is_blank,])) +     scale_fill_distiller(palette = \"Blues\", direction = 1,                          name = \"Counts (real genes)\") +     new_scale_fill() +     geom_bin2d(bins = 50, data = as.data.frame(rowData(sfe)[is_blank,])) +     scale_fill_distiller(palette = \"Reds\", direction = 1,                          name = \"Counts (negative controls)\") +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() +     theme_bw() as.data.frame(rowData(sfe)[is_blank,]) |>      ggplot(aes(means, vars)) +     geom_point() +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() +     theme_bw()"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"spatial-autocorrelation-of-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation of QC metrics","title":"MERFISH mouse liver dataset and considerations of large data","text":"’re quite cells contiguous cell, purely using poly2nb probably good. tried ; making snap large doesn’t work. ’s bad, taking longer song. Try annoy hnsw also try poly2nb (pretty fast) find appropriate k Moran’s . OK, code now. add package just say vignette devel version. nearly bad thought Ah, finally see sizable negative Moran’s ! ’s actually slow thought almost 400,000 cells. blanks clustered tightly around 0. vast majority real genes positive spatial autocorrelation, quite strong. genes negative spatial autocorrelation. Plot top genes positive spatial autocorrelation (devel version Voyager)","code":"bbox_use <- st_as_sfc(st_bbox(c(xmin = 2000, xmax = 2500, ymin = 2000, ymax = 2500))) g <- colGeometry(sfe, \"cellSeg\")[bbox_use,] ggplot(g) + geom_sf() system.time(     colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                    dist_type = \"idw\", k = 5,                                                    style = \"W\") ) system.time(     sfe <- colDataMoransI(sfe, c(\"nCounts\", \"nGenes\", \"volume\"),                            colGraphName = \"knn5\") ) colFeatureData(sfe)[c(\"nCounts\", \"nGenes\", \"volume\"),] sfe <- logNormCounts(sfe) sfe <- runMoransI(sfe, BPPARAM = MulticoreParam(2, progressbar = TRUE)) plotRowData(sfe, x = \"moran_sample01\", y = \"is_blank\") +     geom_hline(yintercept = 0, linetype = 2)"},{"path":"https://pachterlab.github.io/voyager/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lambda Moses. Author, maintainer. Kayla Jackson. Author. Lior Pachter. Author, reviewer.","code":""},{"path":"https://pachterlab.github.io/voyager/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Moses L, Jackson K, Pachter L (2022). Voyager: geospatial spatial omics. R package version 0.99.11, https://github.com/pachterlab/Voyager.","code":"@Manual{,   title = {Voyager: From geospatial to spatial omics},   author = {Lambda Moses and Kayla Jackson and Lior Pachter},   year = {2022},   note = {R package version 0.99.11},   url = {https://github.com/pachterlab/Voyager}, }"},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the elbow plot or scree plot for PCA — ElbowPlot","title":"Plot the elbow plot or scree plot for PCA — ElbowPlot","text":"Apparently, apparent way plot PC elbow plot extracting variance explained attribute dimred slot, even OSCA book makes elbow plot way, find kind cumbersome compared Seurat. writing function make elbow plot SCE less cumbersome.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the elbow plot or scree plot for PCA — ElbowPlot","text":"","code":"ElbowPlot(sce, ndims = 20, reduction = \"PCA\")"},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the elbow plot or scree plot for PCA — ElbowPlot","text":"sce SingleCellExperiment object, anything inherits SingleCellExperiment. ndims Number PCs plot. reduction Name dimension reduction use. must attribute called \"percentVar\". Defaults \"PCA\".","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the elbow plot or scree plot for PCA — ElbowPlot","text":"ggplot object. y axis percentage variance explained.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the elbow plot or scree plot for PCA — ElbowPlot","text":"","code":"library(SFEData) library(scater) #> Loading required package: SingleCellExperiment #> Loading required package: SummarizedExperiment #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: ‘MatrixGenerics’ #> The following objects are masked from ‘package:matrixStats’: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, aperm, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted, #>     lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin, #>     pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table, #>     tapply, union, unique, unsplit, which.max, which.min #> Loading required package: S4Vectors #>  #> Attaching package: ‘S4Vectors’ #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: ‘Biobase’ #> The following object is masked from ‘package:MatrixGenerics’: #>  #>     rowMedians #> The following objects are masked from ‘package:matrixStats’: #>  #>     anyMissing, rowMedians #> Loading required package: scuttle #> Loading required package: ggplot2 sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> require(“SpatialFeatureExperiment”) sfe <- runPCA(sfe, ncomponents = 10, exprs_values = \"counts\") ElbowPlot(sfe, ndims = 10)"},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate spatial stiatistics — calculateUnivariate","title":"Univariate spatial stiatistics — calculateUnivariate","text":"functions compute univariate spatial statistics, global local, matrices, data frames, SFE objects. SFE objects, statistics can computed numeric columns colData, colGeometries, annotGeometries, results stored within SFE object. calculateMoransI runMoransI convenience wrappers calculateUnivariate runUnivariate respectively.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate spatial stiatistics — calculateUnivariate","text":"","code":"# S4 method for ANY calculateUnivariate(   x,   listw,   type = c(\"moran\", \"geary\", \"moran.mc\", \"geary.mc\", \"moran.test\", \"geary.test\",     \"globalG.test\", \"sp.correlogram\", \"moran.plot\", \"localmoran\", \"localmoran_perm\",     \"localC\", \"localC_perm\", \"localG\", \"localG_perm\", \"LOSH\", \"LOSH.mc\", \"LOSH.cs\",     \"gwss\"),   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   p.adjust.method = \"BH\",   ... )  # S4 method for SpatialFeatureExperiment calculateUnivariate(   x,   type,   features = NULL,   colGraphName = 1L,   sample_id = NULL,   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  # S4 method for ANY calculateMoransI(x, ..., BPPARAM = SerialParam(), zero.policy = NULL)  # S4 method for SpatialFeatureExperiment calculateMoransI(   x,   features = NULL,   colGraphName = 1L,   sample_id = NULL,   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  colDataUnivariate(   x,   type,   features,   colGraphName = 1L,   sample_id = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  colDataMoransI(   x,   features,   colGraphName = 1L,   sample_id = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  colGeometryUnivariate(   x,   type,   features,   colGeometryName = 1L,   colGraphName = 1L,   sample_id = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  colGeometryMoransI(   x,   features,   colGeometryName = 1L,   colGraphName = 1L,   sample_id = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  annotGeometryUnivariate(   x,   type,   features,   annotGeometryName = 1L,   annotGraphName = 1L,   sample_id = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  annotGeometryMoransI(   x,   features,   annotGeometryName = 1L,   annotGraphName = 1L,   sample_id = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  runUnivariate(   x,   type,   features = NULL,   colGraphName = 1L,   sample_id = NULL,   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )  runMoransI(   x,   features = NULL,   colGraphName = 1L,   sample_id = NULL,   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate spatial stiatistics — calculateUnivariate","text":"x numeric matrix whose rows features/genes, SpatialFeatureExperiment (SFE) object matrix assay. listw Weighted neighborhood graph spdep listw object. type integer specifying index string specifying name *Geometry query replace. missing, first item *Geometries returned replaced. BPPARAM BiocParallelParam object specifying whether computing metric numerous genes shall parallelized. zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA returnDF Logical, results added SFE object, whether results formatted DataFrame. p.adjust.method Method correct multiple testing, passed p.adjustSP. Methods allowed p.adjust.methods. ... arguments passed S4 method (convenience wrappers like calculateMoransI) method used compute metrics specified argument type (general functions like calculateUnivariate). See documentation spdep package latter. features Genes (calculate* SFE method run*) numeric columns colData(x) (colData*) colGeometry (colGeometry*) annotGeometry (annotGeometry*) univariate metric computed. Default NULL. NULL, metric computed genes values assay specified argument exprs_values. can parallelized argument BPPARAM. genes, column \"symbol\" present rowData row names SFE object Ensembl IDs, gene symbol can used converted IDs behind scene. However, one symbol matches multiple IDs, warning given first match used. Internally, results always stored Ensembl ID rather symbol. colGraphName Name listw graph SFE object corresponds entities represented columns gene count matrix. Use colGraphNames look names available graphs cells/spots. Note multiple sample_ids, assumed graph name. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. exprs_values Integer scalar string indicating assay x contains expression values. include_self Logical, whether spatial neighborhood graph include edges location . Getis-Ord Gi* localG localG_perm, used method. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry sf data frame whose numeric columns interest used compute metric. Use annotGeometryNames look names sf data frames associated annotations. annotGraphName Name listw graph SFE object corresponds annotGeometry interest. Use annotGraphNames look names available annotation graphs.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate spatial stiatistics — calculateUnivariate","text":"calculateUnivariate, returnDF = TRUE,  DataFrame, otherwise list element results   feature. run*, SpatialFeatureExperiment object   results added. See Details results stored.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate spatial stiatistics — calculateUnivariate","text":"univariate methods package spdep supported . methods global, meaning returning one result spatial locations dataset: moran, geary, moran.mc, geary.mc, moran.test, geary.test, globalG.test, sp.correlogram. following methods local, meaning location results: moran.plot, localmoran, localmoran_perm, localC, localC_perm, localG, localG_perm, LOSH, LOSH.mc, LOSH.cs. GWmodel::gwss method supported soon, supported yet. Global results genes stored rowData. colGeometry annotGeometry, results added attribute data frame called featureData, DataFrame analogous rowData gene count matrix. New column names featureData follow rules rowData. colData, results can accessed colFeatureData function. Local results stored field localResults field SFE object, can accessed localResults localResult. results p-values, -log10 p Benjamin-Hochberg corrected -log10 p added. Note multiple testing correction, p.adjustSP used.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate spatial stiatistics — calculateUnivariate","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) features_use <- rownames(sfe)[1:5]  # Moran's I moran_results <- calculateMoransI(sfe,     features = features_use,     colGraphName = \"visium\",     exprs_values = \"counts\" )  # This does not advocate for computing Moran's I on raw counts. # Just an example for function usage.  sfe <- runMoransI(sfe,     features = features_use, colGraphName = \"visium\",     exprs_values = \"counts\" ) # Look at the results head(rowData(sfe)) #> DataFrame with 6 rows and 8 columns #>                               Ensembl      symbol            type       means #>                           <character> <character>     <character>   <numeric> #> ENSMUSG00000025902 ENSMUSG00000025902       Sox17 Gene Expression 0.007612179 #> ENSMUSG00000096126 ENSMUSG00000096126     Gm22307 Gene Expression 0.000200321 #> ENSMUSG00000033845 ENSMUSG00000033845      Mrpl15 Gene Expression 0.075921474 #> ENSMUSG00000025903 ENSMUSG00000025903      Lypla1 Gene Expression 0.057491987 #> ENSMUSG00000033813 ENSMUSG00000033813       Tcea1 Gene Expression 0.052283654 #> ENSMUSG00000002459 ENSMUSG00000002459       Rgs20 Gene Expression 0.000200321 #>                           vars       cv2 moran_Vis5A   K_Vis5A #>                      <numeric> <numeric>   <numeric> <numeric> #> ENSMUSG00000025902 0.008757912  151.1411  -0.0424335  13.32749 #> ENSMUSG00000096126 0.000200321 4992.0000         NaN       NaN #> ENSMUSG00000033845 0.114250804   19.8212   0.2485804   5.41594 #> ENSMUSG00000025903 0.080645121   24.3985   0.0070062   9.46309 #> ENSMUSG00000033813 0.073603279   26.9256   0.1592157   8.51384 #> ENSMUSG00000002459 0.000200321 4992.0000          NA        NA  # Local Moran's I sfe <- runUnivariate(sfe,     type = \"localmoran\", features = features_use,     colGraphName = \"visium\", exprs_values = \"counts\" ) head(localResult(sfe, \"localmoran\", features_use[1])) #>                           Ii         E.Ii     Var.Ii       Z.Ii Pr(z != E(Ii)) #> AAATTACCTATCGATG -0.02897069 -0.001345388 0.01609308 -0.2177647     0.82761246 #> AACATATCAACTGGTG -0.29141104 -0.001345388 0.01609308 -2.2865292     0.02222332 #> AAGATTGGCGGAACGT  0.10224949 -0.001345388 0.01958757  0.7401981     0.45917982 #> AAGGGACAGATTCTGT -0.02897069 -0.001345388 0.01609308 -0.2177647     0.82761246 #> AATATCGAGGGTTCTC  0.10224949 -0.001345388 0.01609308  0.8166176     0.41414701 #> AATGATGATACGCTAT  0.10224949 -0.001345388 0.01609308  0.8166176     0.41414701 #>                      mean   median    pysal    -log10p -log10p_adj #> AAATTACCTATCGATG Low-High Low-High Low-High 0.08217298   0.0000000 #> AACATATCAACTGGTG Low-High Low-High Low-High 1.65319110   0.8080931 #> AAGATTGGCGGAACGT  Low-Low  Low-Low  Low-Low 0.33801720   0.0000000 #> AAGGGACAGATTCTGT Low-High Low-High Low-High 0.08217298   0.0000000 #> AATATCGAGGGTTCTC  Low-Low  Low-Low  Low-Low 0.38284547   0.0000000 #> AATGATGATACGCTAT  Low-Low  Low-Low  Low-Low 0.38284547   0.0000000  # For colData sfe <- colDataUnivariate(sfe,     type = \"localmoran\", features = \"nCounts\",     colGraphName = \"visium\" ) head(localResult(sfe, \"localmoran\", \"nCounts\")) #>                           Ii          E.Ii      Var.Ii       Z.Ii #> AAATTACCTATCGATG  0.53682603 -0.0073375879 0.087243111  1.8423152 #> AACATATCAACTGGTG  0.20017125 -0.0008174853 0.009783652  2.0319883 #> AAGATTGGCGGAACGT  0.13533683 -0.0002992400 0.004361215  2.0538630 #> AAGGGACAGATTCTGT  0.67946203 -0.0182482408 0.214584793  1.5061757 #> AATATCGAGGGTTCTC -0.01287299 -0.0009633914 0.011528171 -0.1109218 #> AATGATGATACGCTAT  0.15331553 -0.0306802864 0.356207210  0.3082880 #>                  Pr(z != E(Ii))      mean    median     pysal    -log10p #> AAATTACCTATCGATG     0.06542906 High-High High-High High-High 1.18422931 #> AACATATCAACTGGTG     0.04215484 High-High High-High High-High 1.37515260 #> AAGATTGGCGGAACGT     0.03998896 High-High  Low-High High-High 1.39805992 #> AAGGGACAGATTCTGT     0.13202207 High-High High-High High-High 0.87935347 #> AATATCGAGGGTTCTC     0.91167838  High-Low  High-Low  High-Low 0.04015835 #> AATGATGATACGCTAT     0.75786321 High-High  High-Low High-High 0.12040917 #>                  -log10p_adj #> AAATTACCTATCGATG  0.33913127 #> AACATATCAACTGGTG  0.53005456 #> AAGATTGGCGGAACGT  0.61990867 #> AAGGGACAGATTCTGT  0.03425543 #> AATATCGAGGGTTCTC  0.00000000 #> AATGATGATACGCTAT  0.00000000  # For annotGeometries annotGraph(sfe, \"myofiber_tri2nb\") <-     findSpatialNeighbors(sfe,         type = \"myofiber_simplified\", MARGIN = 3L,         method = \"tri2nb\", dist_type = \"idw\",         zero.policy = TRUE     ) sfe <- annotGeometryUnivariate(sfe,     type = \"localG\", features = \"area\",     annotGraphName = \"myofiber_tri2nb\",     annotGeometryName = \"myofiber_simplified\",     zero.policy = TRUE ) head(localResult(sfe, \"localG\", \"area\",     annotGeometryName = \"myofiber_simplified\" )) #> [1] -2.3083710 -0.8140180  0.0508039 -0.1700897  0.1547597 -0.3688569"},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":null,"dir":"Reference","previous_headings":"","what":"Find clusters of correlogram patterns — clusterCorrelograms","title":"Find clusters of correlogram patterns — clusterCorrelograms","text":"Cluster correlograms find patterns length scales spatial autocorrelation. correlograms clustered must computed method number lags.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find clusters of correlogram patterns — clusterCorrelograms","text":"","code":"clusterCorrelograms(   sfe,   features,   BLUSPARAM,   sample_id = NULL,   method = \"I\",   colGeometryName = NULL,   annotGeometryName = NULL,   show_symbol = TRUE )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find clusters of correlogram patterns — clusterCorrelograms","text":"sfe SpatialFeatureExperiment object correlograms computed features interest. features Features whose correlograms cluster. BLUSPARAM BlusterParam object specifying algorithm use. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. method \"corr\" correlation, \"\" Moran's , \"C\" Geary's C colGeometryName Name colGeometry look features. annotGeometryName Name annotGeometry look features. show_symbol Logical, whether show gene symbol instead Ensembl ID supplied.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find clusters of correlogram patterns — clusterCorrelograms","text":"DataFrame 3 columns: feature features, cluster factor cluster membership features within sample, sample_id sample.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find clusters of correlogram patterns — clusterCorrelograms","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(bluster) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) inds <- c(1, 3, 4, 5) sfe <- runUnivariate(sfe,     type = \"sp.correlogram\",     features = rownames(sfe)[inds],     exprs_values = \"counts\", order = 5 ) clust <- clusterCorrelograms(sfe,     features = rownames(sfe)[inds],     BLUSPARAM = KmeansParam(2) )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Find clusters on the Moran plot — clusterMoranPlot","title":"Find clusters on the Moran plot — clusterMoranPlot","text":"Moran plot plots value location x axis, average neighbors locations y axis. Sometimes clusters can seen Moran plot, indicating different types neighborhoods.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find clusters on the Moran plot — clusterMoranPlot","text":"","code":"clusterMoranPlot(   sfe,   features,   BLUSPARAM,   sample_id = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   show_symbol = TRUE )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find clusters on the Moran plot — clusterMoranPlot","text":"sfe SpatialFeatureExperiment object Moran plot computed feature interest. Moran plot feature computed feature sample_id, calculated stored rowData. See calculateUnivariate. features Features whose Moran plot cluster. Features whose Moran plots computed skipped, warning. BLUSPARAM BlusterParam object specifying algorithm use. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. colGeometryName Name colGeometry look features. annotGeometryName Name annotGeometry look features. show_symbol Logical, whether show gene symbol instead Ensembl ID supplied.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find clusters on the Moran plot — clusterMoranPlot","text":"DataFrame column factor cluster   membership feature. column names features.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find clusters on the Moran plot — clusterMoranPlot","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) library(bluster) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) # Compute moran plot sfe <- runUnivariate(sfe,     type = \"moran.plot\", features = rownames(sfe)[1],     exprs_values = \"counts\" ) clusts <- clusterMoranPlot(sfe, rownames(sfe)[1],     BLUSPARAM = KmeansParam(2) )"},{"path":"https://pachterlab.github.io/voyager/reference/colFeatureData.html","id":null,"dir":"Reference","previous_headings":"","what":"Get metadata of colData and rowData — colFeatureData","title":"Get metadata of colData and rowData — colFeatureData","text":"Results spatial analyses columns colData rowData stored int_metadata(sfe), internal metadata. function allows users access results.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/colFeatureData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get metadata of colData and rowData — colFeatureData","text":"","code":"colFeatureData(sfe)  rowFeatureData(sfe)"},{"path":"https://pachterlab.github.io/voyager/reference/colFeatureData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get metadata of colData and rowData — colFeatureData","text":"sfe SFE object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/colFeatureData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get metadata of colData and rowData — colFeatureData","text":"DataFrame.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/colFeatureData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get metadata of colData and rowData — colFeatureData","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) # Moran's I for colData sfe <- colDataMoransI(sfe, \"nCounts\") colFeatureData(sfe) #> DataFrame with 12 rows and 2 columns #>           moran_Vis5A   K_Vis5A #>             <numeric> <numeric> #> barcode            NA        NA #> col                NA        NA #> row                NA        NA #> x                  NA        NA #> y                  NA        NA #> ...               ...       ... #> sample_id          NA        NA #> nCounts      0.675416   1.67027 #> nGenes             NA        NA #> prop_mito          NA        NA #> in_tissue          NA        NA"},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Colorblind friendly palette from dittoSeq — ditto_colors","title":"Colorblind friendly palette from dittoSeq — ditto_colors","text":"Just get palette without install dependencies dittoSeq.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Colorblind friendly palette from dittoSeq — ditto_colors","text":"","code":"ditto_colors"},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Colorblind friendly palette from dittoSeq — ditto_colors","text":"character vector hex colors palette. 40 colors.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Colorblind friendly palette from dittoSeq — ditto_colors","text":"dittoSeq package.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":null,"dir":"Reference","previous_headings":"","what":"Get beginning and end of palette to center a divergent palette — getDivergeRange","title":"Get beginning and end of palette to center a divergent palette — getDivergeRange","text":"title self-explanatory.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get beginning and end of palette to center a divergent palette — getDivergeRange","text":"","code":"getDivergeRange(values, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get beginning and end of palette to center a divergent palette — getDivergeRange","text":"values Numeric vector colored. diverge_center Value center , defaults 0.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get beginning and end of palette to center a divergent palette — getDivergeRange","text":"numeric vector length 2, first element beginning, second end. values 0 1.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get beginning and end of palette to center a divergent palette — getDivergeRange","text":"","code":"v <- rnorm(10) getDivergeRange(v, diverge_center = 0) #> [1] 0.212455 1.000000"},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Use ggplot to plot the moran.plot results — moranPlot","title":"Use ggplot to plot the moran.plot results — moranPlot","text":"function uses ggplot2 plot Moran plot. plot aesthetically pleasing base R version implemented spdep. addition, contours plotted show point density plot, points can colored variable, clusters. contours may also filled influential points plotted. filled, viridis E option used.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use ggplot to plot the moran.plot results — moranPlot","text":"","code":"moranPlot(   sfe,   feature,   graphName = 1L,   sample_id = NULL,   contour_color = \"cyan\",   color_by = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   plot_singletons = TRUE,   binned = FALSE,   filled = FALSE,   divergent = FALSE,   diverge_center = NULL,   show_symbol = TRUE,   bins = 100,   binwidth = NULL,   hex = FALSE,   plot_influential = TRUE,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use ggplot to plot the moran.plot results — moranPlot","text":"sfe SpatialFeatureExperiment object. feature Name one variable show plot. converted sentence case x axis lower case y axis appended \"Spatially lagged\". One feature time since colors color_by may specific feature (e.g. clusterMoranPlot). graphName Name colGraph annotGraph, spatial neighborhood graph used compute Moran plot. determine points singletons plot differently plot. sample_id One sample_id sample whose graph plot. contour_color Color point density contours, can changed contours stand points. color_by Variable color points . can name column colData, gene, name column colGeometry specified colGeometryName. can vector length number cells/spots sample_id interest. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. plot_singletons Logical, whether plot items spatial neighbors. binned Logical, whether plot 2D histograms. argument precedence filled. filled Logical, whether plot filled contours non-influential points plot influential points points. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. show_symbol Logical, whether show human readable gene symbol plot instead Ensembl IDs row names Ensembl IDs. must column rowData(sfe) called \"symbol\" work. bins Numeric vector giving number bins vertical horizontal directions. Set 100 default. binwidth Numeric vector giving bin width vertical horizontal directions. Overrides bins set. hex Logical, whether use hexagon rather rectangular bins. Requires hexbin package. plot_influential Logical, whether plot influential points different palette binned = TRUE. ... arguments pass geom_density2d.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use ggplot to plot the moran.plot results — moranPlot","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use ggplot to plot the moran.plot results — moranPlot","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) library(bluster) library(scater) sfe <- McKellarMuscleData(\"full\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache sfe <- sfe[, colData(sfe)$in_tissue] sfe <- logNormCounts(sfe) colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) sfe <- runUnivariate(sfe, type = \"moran.plot\", features = \"Myh1\") clust <- clusterMoranPlot(sfe, \"Myh1\", BLUSPARAM = KmeansParam(2)) moranPlot(sfe, \"Myh1\", graphName = \"visium\", color_by = clust[, 1])"},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cell density as 2D histogram — plotCellBin2D","title":"Plot cell density as 2D histogram — plotCellBin2D","text":"function plots cell density histological space 2D histograms,  especially helpful larger smFISH-based datasets.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cell density as 2D histogram — plotCellBin2D","text":"","code":"plotCellBin2D(sfe, bins = 200, binwidth = NULL, hex = FALSE)"},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cell density as 2D histogram — plotCellBin2D","text":"sfe SpatialFeatureExperiment object. bins Numeric vector giving number bins vertical horizontal directions. Set 100 default. binwidth Numeric vector giving bin width vertical horizontal directions. Overrides bins set. hex Logical, whether use hexagon rather rectangular bins. Requires hexbin package.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cell density as 2D histogram — plotCellBin2D","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cell density as 2D histogram — plotCellBin2D","text":"","code":"library(SFEData) sfe <- HeNSCLCData() #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache plotCellBin2D(sfe)"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataBin2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot colData and rowData with 2D histograms — plotColDataBin2D","title":"Plot colData and rowData with 2D histograms — plotColDataBin2D","text":"avoid overplotting large datasets. 2D histogram informative point density plot scatter plot many points plotted effectively form solid block.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataBin2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot colData and rowData with 2D histograms — plotColDataBin2D","text":"","code":"plotColDataBin2D(   sfe,   x,   y,   subset = NULL,   bins = 100,   binwidth = NULL,   hex = FALSE,   name_true = NULL,   name_false = NULL )  plotRowDataBin2D(   sfe,   x,   y,   subset = NULL,   bins = 100,   binwidth = NULL,   hex = FALSE,   name_true = NULL,   name_false = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataBin2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot colData and rowData with 2D histograms — plotColDataBin2D","text":"sfe SpatialFeatureExperiment object. x Name column colData rowData plot x axis plot. y Name column colData rowData plot y axis plot. subset Name logical column colData rowData, indicating cells genes plot different palette. Since 2D histogram effectively opaque heatmap, use argument unless two groups largely non-overlapping variables plotted. bins Numeric vector giving number bins vertical horizontal directions. Set 100 default. binwidth Numeric vector giving bin width vertical horizontal directions. Overrides bins set. hex Logical, whether use hexagon rather rectangular bins. Requires hexbin package. name_true Character, name show legend cells genes indicated TRUE subset argument. name_false Character, name show legend cells genes indicated FALSE subset argument.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataBin2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot colData and rowData with 2D histograms — plotColDataBin2D","text":"ggplot object","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataBin2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot colData and rowData with 2D histograms — plotColDataBin2D","text":"","code":"library(SFEData) sfe <- McKellarMuscleData() #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- sfe[, sfe$in_tissue] plotColDataBin2D(sfe, \"nCounts\", \"nGenes\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot histograms for colData and rowData columns — plotColDataHistogram","title":"Plot histograms for colData and rowData columns — plotColDataHistogram","text":"Plot histograms colData rowData columns","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot histograms for colData and rowData columns — plotColDataHistogram","text":"","code":"plotColDataHistogram(   sfe,   feature,   fill_by = NULL,   subset = NULL,   bins = 100,   binwidth = NULL,   scales = \"free\",   ncol = 1,   position = \"identity\" )  plotRowDataHistogram(   sfe,   feature,   fill_by = NULL,   subset = NULL,   bins = 100,   binwidth = NULL,   scales = \"free\",   ncol = 1,   position = \"identity\" )"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot histograms for colData and rowData columns — plotColDataHistogram","text":"sfe SpatialFeatureExperiment object. feature Names columns colData rowData plot. multiple features specified, plotted separate facets. fill_by Name categorical column colData rowData fill histogram. subset Name logical column plot subset data. bins Numeric vector giving number bins vertical horizontal directions. Set 100 default. binwidth Numeric vector giving bin width vertical horizontal directions. Overrides bins set. scales scales fixed (\"fixed\", default), free (\"free\"), free one dimension (\"free_x\", \"free_y\")? ncol Number columns facetting. position Position adjustment, either string, result call position adjustment function.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot histograms for colData and rowData columns — plotColDataHistogram","text":"ggplot object","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot histograms for colData and rowData columns — plotColDataHistogram","text":"","code":"library(SFEData) sfe <- McKellarMuscleData() #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache plotColDataHistogram(sfe, c(\"nCounts\", \"nGenes\"), fill_by = \"in_tissue\",                      bins = 50)  plotColDataHistogram(sfe, \"nCounts\", subset = \"in_tissue\")  sfe2 <- sfe[, sfe$in_tissue] plotColDataHistogram(sfe2, c(\"nCounts\", \"nGenes\"), bins = 50)"},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatial graphs — plotColGraph","title":"Plot spatial graphs — plotColGraph","text":"ggplot version spdep::plot.nb, reducing boilerplate SFE objects.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatial graphs — plotColGraph","text":"","code":"plotColGraph(   sfe,   colGraphName = 1L,   colGeometryName = NULL,   sample_id = NULL,   weights = FALSE,   segment_size = 0.5,   geometry_size = 0.5,   ncol = NULL )  plotAnnotGraph(   sfe,   annotGraphName = 1L,   annotGeometryName = 1L,   sample_id = NULL,   weights = FALSE,   segment_size = 0.5,   geometry_size = 0.5,   ncol = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatial graphs — plotColGraph","text":"sfe SpatialFeatureExperiment object. colGraphName Name graph associated columns gene count matrix plotted. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. weights Whether plot weights. TRUE, transparency (alpha) segments represent edge weights. segment_size Thickness segments represent graph edges. geometry_size Point size (POINT geometries) line thickness (LINESTRING POLYGON) plot geometry background. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. annotGraphName Name annotation graph plot. annotGeometryName Name annotGeometry, associated graph specified annotGraphName, spatial coordinates graph nodes context.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot spatial graphs — plotColGraph","text":"ggplot2 object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatial graphs — plotColGraph","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(sf) #> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) plotColGraph(sfe, colGraphName = \"visium\", colGeometryName = \"spotPoly\")  # Make the myofiber segmentations a valid POLYGON geometry ag <- annotGeometry(sfe, \"myofiber_simplified\") ag <- st_buffer(ag, 0) ag <- ag[!st_is_empty(ag), ] annotGeometry(sfe, \"myofiber_simplified\") <- ag annotGraph(sfe, \"myofibers\") <-     findSpatialNeighbors(sfe,         type = \"myofiber_simplified\", MARGIN = 3,         method = \"tri2nb\", dist_type = \"idw\"     ) plotAnnotGraph(sfe,     annotGraphName = \"myofibers\",     annotGeometryName = \"myofiber_simplified\",     weights = TRUE )"},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot correlogram — plotCorrelogram","title":"Plot correlogram — plotCorrelogram","text":"Use ggplot2 plot correlograms computed runUnivariate, pulling results rowData. Correlograms multiple genes error bars can plotted, can colored numeric categorical column rowData vector length nrow SFE object. coloring useful correlograms clustered show types length scales patterns decay spatial autocorrelation. method = \"\", error bars twice standard deviation estimated Moran's value.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot correlogram — plotCorrelogram","text":"","code":"plotCorrelogram(   sfe,   features,   sample_id = NULL,   method = \"I\",   color_by = NULL,   facet_by = c(\"sample_id\", \"features\"),   ncol = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   plot_signif = TRUE,   p_adj_method = \"BH\",   divergent = FALSE,   diverge_center = NULL,   show_symbol = TRUE )"},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot correlogram — plotCorrelogram","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. method \"corr\" correlation, \"\" Moran's , \"C\" Geary's C color_by Name column rowData(sfe) featureData colData (see colFeatureData), colGeometry, annotGeometry color correlogram feature. Alternatively, vector length features. facet_by Whether facet sample_id (default) features. facetting sample_id, different features plotted facet comparison. facetting features, different samples compared feature. Ignored one sample specified. ncol Number columns facetting. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. plot_signif Logical, whether plot significance symbols: p < 0.001: ***, p < 0.01: **, p < 0.05 *, p < 0.1: ., otherwise symbol. p-values two sided, based assumption estimated Moran's normally distributed mean randomized version data. mean variance come moran.test Moran's geary.test Geary's C. Take results grain salt data normally distributed. p_adj_method Multiple testing correction method p.adjust, correct multiple testing (number lags times number features) Moran's estimates plot_signif = TRUE. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. show_symbol Logical, whether show human readable gene symbol plot instead Ensembl IDs row names Ensembl IDs. must column rowData(sfe) called \"symbol\" work.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot correlogram — plotCorrelogram","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot correlogram — plotCorrelogram","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(bluster) library(scater) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- logNormCounts(sfe) colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) inds <- c(1, 3, 4, 5) features <- rownames(sfe)[inds] sfe <- runUnivariate(sfe,     type = \"sp.correlogram\", features = features,     exprs_values = \"counts\", order = 5 ) clust <- clusterCorrelograms(sfe,     features = features,     BLUSPARAM = KmeansParam(2) ) # Color by features plotCorrelogram(sfe, features)  # Color by something else plotCorrelogram(sfe, features, color_by = clust$cluster)  # Facet by features plotCorrelogram(sfe, features, facet_by = \"features\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot top PC loadings of genes — plotDimLoadings","title":"Plot top PC loadings of genes — plotDimLoadings","text":"Just like Seurat's VizDimLoadings function. found equivalent SCE find useful. trying reproduce Seurat function exactly. instance, like Seurat imposes ggplot theme, like cowplot theme. Maybe rewrite base R now using Tidyverse.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot top PC loadings of genes — plotDimLoadings","text":"","code":"plotDimLoadings(   sce,   dims = 1:4,   nfeatures = 10,   show_symbol = TRUE,   symbol_col = \"symbol\",   reduction = \"PCA\",   balanced = TRUE,   ncol = 2 )"},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot top PC loadings of genes — plotDimLoadings","text":"sce SingleCellExperiment object, anything inherits SingleCellExperiment. dims Numeric vector specifying PCs plot. nfeatures Number genes plot. show_symbol Logical; row names matrix Ensembl accessions, indicate whether show human readable gene symbols plot instead. Ignored column specified symbol_col absent rowData. symbol_col row names gene expression matrix Ensembl accessions avoid ambiguity analysis. found rowData, rownames gene count matrix used. reduction Name dimension reduction use. must attribute called \"percentVar\". Defaults \"PCA\". balanced Return equal number genes + - scores. FALSE, returns top genes ranked scores absolute values. ncol Number columns facetted plot.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot top PC loadings of genes — plotDimLoadings","text":"ggplot object. Loadings different PCs plotted different   facets one ggplot object returned.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot top PC loadings of genes — plotDimLoadings","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- runPCA(sfe, ncomponents = 10, exprs_values = \"counts\") plotDimLoadings(sfe, dims = 1:2)"},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot local results — plotLocalResult","title":"Plot local results — plotLocalResult","text":"Plot results local spatial analyses space, local Getis-Ord Gi* values.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot local results — plotLocalResult","text":"","code":"plotLocalResult(   sfe,   type,   features,   attribute = NULL,   sample_id = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   ncol = NULL,   ncol_sample = NULL,   annot_aes = list(),   annot_fixed = list(),   aes_use = c(\"fill\", \"color\", \"shape\", \"linetype\"),   divergent = FALSE,   diverge_center = NULL,   annot_divergent = FALSE,   annot_diverge_center = NULL,   size = 0,   shape = 16,   linetype = 1,   alpha = 1,   color = NA,   fill = \"gray80\",   show_symbol = TRUE,   scattermore = FALSE,   pointsize = 0,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot local results — plotLocalResult","text":"sfe SpatialFeatureExperiment object. type local spatial results. Use localResultNames see types results already calculated. features Character vector vectors. see features results given type, see localResultFeatures. attribute field local results type features. result feature vector, argument ignored. result data frame matrix, column name result, \"Ii\" local Moran's . local spatial analysis method, default attribute. See Details. Use localResultAttrs. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. ncol_sample plotting multiple samples facets, many columns facets. distinct ncols, multiple features. plotting multiple features multiple samples, result multi-panel plot panel plot feature facetted samples. annot_aes named list plotting parameters annotation sf data frame. names geom (ggplot2, color fill), values column names annotation sf data frame. Tidyeval supported. annot_fixed Similar annot_aes, fixed aesthetic settings, color = \"gray\". defaults relevant defaults function. aes_use Aesthetic use discrete variables. continuous variables, always \"fill\" polygons point shapes 21-25. discrete variables, can fill, color, shape, linetype, whenever applicable. specified value changed applicable equivalent. example, geometry point \"linetype\" specified, \"shaped\" used instead. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. annot_divergent Just divergent, annotGeometry case different. annot_diverge_center Just diverge_center, annotGeometry case different. size Fixed size points width lines, including outlines polygons. polygons, defaults 0, meaning outlines. points lines, defaults 0.5. Ignored size_by specified. shape Fixed shape points, ignored shape_by specified applicable. linetype Fixed line type, ignored linetype_by specified applicable. alpha Transparency. color Fixed color colGeometry color_by specified applicable, annotGeometry annot_color_by specified applicable. fill Similar color, fill. show_symbol Logical, whether show human readable gene symbol plot instead Ensembl IDs row names Ensembl IDs. must column rowData(sfe) called \"symbol\" work. scattermore Logical, whether use scattermore package greatly speed plotting numerous points. used POINT colGeometries. geometry POINT, centroids used. Recommended plotting hundreds thousands cells cell polygons seen plotted due large number cells small plot size plotting multiple panels multiple features. pointsize Radius rasterized point scattermore. Default 0 single pixels (fastest). ... arguments passed wrap_plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot local results — plotLocalResult","text":"ggplot2 object plotting one feature. patchwork object plotting multiple features.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot local results — plotLocalResult","text":"Many local spatial analyses return data frame matrix results, whose columns can statistic interest location, variance, expected value permutation, p-value, etc. attribute argument specifies column use multiple columns. defaults local method supported package mean: localmoran localmoran_perm Ii, local Moran's statistic location. localC_perm localC, local Geary C statistic location. localG localG_perm localG, local Getis-Ord Gi Gi* statistic. include_self = TRUE calculateUnivariate runUnivariate called, Gi*. Otherwise Gi. LOSH LOSH.mc Hi, local spatial heteroscedasticity moran.plot wx, average value neighbor location. Moran plot best plotted scatter plot wx vs x. See moranPlot. local methods listed return vectors results. instance, localC returns vector default, local Geary's C statistic.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Plot local results — plotLocalResult","text":"function shares internals   plotSpatialFeature, important differences.   plotSpatialFeature, annotGeometry indeed   used annotation protagonist colGeometry, since   easy directly use ggplot2 plot data   annotGeometry sf data frames overlaying   annotGeometry colGeometry involves complicated code.   contrast, function, local results annotGeometry can   plotted separately without anything related colGeometry. Note   annotGeometry local results plotted without   colGeometry, annot_* arguments ignored. Use   arguments aesthetics colGeometry.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot local results — plotLocalResult","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) feature_use <- rownames(sfe)[1] sfe <- logNormCounts(sfe) sfe <- runUnivariate(sfe, \"localmoran\", feature_use) # Which types of results are available? localResultNames(sfe) #> [1] \"localmoran\" # Which features for localmoran? localResultFeatures(sfe, \"localmoran\") #> [1] \"ENSMUSG00000025902\" # Which columns does the localmoran results have? localResultAttrs(sfe, \"localmoran\", feature_use) #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\"    plotLocalResult(sfe, \"localmoran\", feature_use, \"Ii\",     colGeometryName = \"spotPoly\" )   # For annotGeometry # Make sure it's type POLYGON annotGeometry(sfe, \"myofiber_simplified\") <-     sf::st_buffer(annotGeometry(sfe, \"myofiber_simplified\"), 0) annotGraph(sfe, \"poly2nb_myo\") <-     findSpatialNeighbors(sfe,         type = \"myofiber_simplified\", MARGIN = 3,         method = \"poly2nb\", zero.policy = TRUE     ) sfe <- annotGeometryUnivariate(sfe, \"localmoran\",     features = \"area\",     annotGraphName = \"poly2nb_myo\",     annotGeometryName = \"myofiber_simplified\",     zero.policy = TRUE ) plotLocalResult(sfe, \"localmoran\", \"area\", \"Ii\",     annotGeometryName = \"myofiber_simplified\",     size = 0.3, color = \"cyan\" )  plotLocalResult(sfe, \"localmoran\", \"area\", \"Z.Ii\",     annotGeometryName = \"myofiber_simplified\" )  # don't use annot_* arguments when annotGeometry is plotted without colGeometry"},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Moran/Geary monte carlo results — plotMoranMC","title":"Plot Moran/Geary monte carlo results — plotMoranMC","text":"Plot simulations density plot histogram compared observed Moran's Geary's C, ggplot2 looks nicer. Unlike plotting function spdep, function can also plot feature different samples facets plot different features samples together comparison.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Moran/Geary monte carlo results — plotMoranMC","text":"","code":"plotMoranMC(   sfe,   features,   sample_id = NULL,   facet_by = c(\"sample_id\", \"features\"),   ncol = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   ptype = c(\"density\", \"histogram\", \"freqpoly\"),   show_symbol = TRUE,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Moran/Geary monte carlo results — plotMoranMC","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. facet_by Whether facet sample_id (default) features. facetting sample_id, different features plotted facet comparison. facetting features, different samples compared feature. Ignored one sample specified. ncol Number columns facetting. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. ptype Plot type, one \"density\", \"histogram\", \"freqpoly\". show_symbol Logical, whether show human readable gene symbol plot instead Ensembl IDs row names Ensembl IDs. must column rowData(sfe) called \"symbol\" work. ... arguments passed geom_density, geom_histogram, geom_freqpoly, depending ptype.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Moran/Geary monte carlo results — plotMoranMC","text":"ggplot2 object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Moran/Geary monte carlo results — plotMoranMC","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) sfe <- colDataUnivariate(sfe, type = \"moran.mc\", \"nCounts\", nsim = 100) plotMoranMC(sfe, \"nCounts\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot gene expression in space — plotSpatialFeature","title":"Plot gene expression in space — plotSpatialFeature","text":"Unlike Seurat ggspavis, plotting functions package uses geom_sf whenever applicable.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot gene expression in space — plotSpatialFeature","text":"","code":"plotSpatialFeature(   sfe,   features,   colGeometryName = 1L,   sample_id = NULL,   ncol = NULL,   ncol_sample = NULL,   annotGeometryName = NULL,   annot_aes = list(),   annot_fixed = list(),   exprs_values = \"logcounts\",   aes_use = c(\"fill\", \"color\", \"shape\", \"linetype\"),   divergent = FALSE,   diverge_center = NULL,   annot_divergent = FALSE,   annot_diverge_center = NULL,   size = 0,   shape = 16,   linetype = 1,   alpha = 1,   color = NA,   fill = \"gray80\",   show_symbol = TRUE,   scattermore = FALSE,   pointsize = 0,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot gene expression in space — plotSpatialFeature","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. ncol_sample plotting multiple samples facets, many columns facets. distinct ncols, multiple features. plotting multiple features multiple samples, result multi-panel plot panel plot feature facetted samples. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. annot_aes named list plotting parameters annotation sf data frame. names geom (ggplot2, color fill), values column names annotation sf data frame. Tidyeval supported. annot_fixed Similar annot_aes, fixed aesthetic settings, color = \"gray\". defaults relevant defaults function. exprs_values Integer scalar string indicating assay x contains expression values. aes_use Aesthetic use discrete variables. continuous variables, always \"fill\" polygons point shapes 21-25. discrete variables, can fill, color, shape, linetype, whenever applicable. specified value changed applicable equivalent. example, geometry point \"linetype\" specified, \"shaped\" used instead. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. annot_divergent Just divergent, annotGeometry case different. annot_diverge_center Just diverge_center, annotGeometry case different. size Fixed size points width lines, including outlines polygons. polygons, defaults 0, meaning outlines. points lines, defaults 0.5. Ignored size_by specified. shape Fixed shape points, ignored shape_by specified applicable. linetype Fixed line type, ignored linetype_by specified applicable. alpha Transparency. color Fixed color colGeometry color_by specified applicable, annotGeometry annot_color_by specified applicable. fill Similar color, fill. show_symbol Logical, whether show human readable gene symbol plot instead Ensembl IDs row names Ensembl IDs. must column rowData(sfe) called \"symbol\" work. scattermore Logical, whether use scattermore package greatly speed plotting numerous points. used POINT colGeometries. geometry POINT, centroids used. Recommended plotting hundreds thousands cells cell polygons seen plotted due large number cells small plot size plotting multiple panels multiple features. pointsize Radius rasterized point scattermore. Default 0 single pixels (fastest). ... arguments passed wrap_plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot gene expression in space — plotSpatialFeature","text":"ggplot2 object plotting one feature. patchwork object plotting multiple features.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot gene expression in space — plotSpatialFeature","text":"documentation function, \"feature\" can gene (whatever entity corresponds rows gene count matrix), column colData, column colGeometry sf data frame specified colGeometryName argument. continuous variables, Blues palette colorbrewer used divergent = FALSE, roma palette scico package divergent = TRUE. discrete variables, dittoSeq palette used. defaults colorblind friendly. annotation, PuRd colorbrewer palette used continuous variables end dittoSeq palette used discrete variables.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot gene expression in space — plotSpatialFeature","text":"","code":"library(SFEData) library(sf) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache # features can be genes or colData or colGeometry columns plotSpatialFeature(sfe, c(\"nCounts\", rownames(sfe)[1]),     exprs_values = \"counts\",     colGeometryName = \"spotPoly\",     annotGeometryName = \"tissueBoundary\" )  # Change fixed aesthetics plotSpatialFeature(sfe, \"nCounts\",     colGeometryName = \"spotPoly\",     annotGeometryName = \"tissueBoundary\",     annot_fixed = list(color = \"blue\", size = 0.3, fill = NA),     alpha = 0.7 )  # Make the myofiber segmentations a valid POLYGON geometry ag <- annotGeometry(sfe, \"myofiber_simplified\") ag <- st_buffer(ag, 0) ag <- ag[!st_is_empty(ag), ] annotGeometry(sfe, \"myofiber_simplified\") <- ag # Also plot an annotGeometry variable plotSpatialFeature(sfe, \"nCounts\",     colGeometryName = \"spotPoly\",     annotGeometryName = \"myofiber_simplified\",     annot_aes = list(fill = \"area\") )"},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dimension reduction components in space — spatialReducedDim","title":"Plot dimension reduction components in space — spatialReducedDim","text":"plotting value projection gene expression cell principal component space. present, function work 3D array geographically weighted PCA (GWPCA), future version deal GWPCA results.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dimension reduction components in space — spatialReducedDim","text":"","code":"spatialReducedDim(   sfe,   dimred,   ncomponents,   colGeometryName = 1L,   sample_id = NULL,   ncol = NULL,   ncol_sample = NULL,   annotGeometryName = NULL,   annot_aes = list(),   annot_fixed = list(),   exprs_values = \"logcounts\",   aes_use = c(\"fill\", \"color\", \"shape\", \"linetype\"),   divergent = FALSE,   diverge_center = NULL,   annot_divergent = FALSE,   annot_diverge_center = NULL,   size = 0,   shape = 16,   linetype = 1,   alpha = 1,   color = NA,   fill = \"gray80\",   scattermore = FALSE,   pointsize = 0,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dimension reduction components in space — spatialReducedDim","text":"sfe SpatialFeatureExperiment object. dimred string integer scalar indicating reduced dimension result reducedDims(sfe) plot. ncomponents numeric scalar indicating number dimensions plot, starting first dimension. Alternatively, numeric vector specifying dimensions plotted. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. ncol_sample plotting multiple samples facets, many columns facets. distinct ncols, multiple features. plotting multiple features multiple samples, result multi-panel plot panel plot feature facetted samples. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. annot_aes named list plotting parameters annotation sf data frame. names geom (ggplot2, color fill), values column names annotation sf data frame. Tidyeval supported. annot_fixed Similar annot_aes, fixed aesthetic settings, color = \"gray\". defaults relevant defaults function. exprs_values Integer scalar string indicating assay x contains expression values. aes_use Aesthetic use discrete variables. continuous variables, always \"fill\" polygons point shapes 21-25. discrete variables, can fill, color, shape, linetype, whenever applicable. specified value changed applicable equivalent. example, geometry point \"linetype\" specified, \"shaped\" used instead. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. annot_divergent Just divergent, annotGeometry case different. annot_diverge_center Just diverge_center, annotGeometry case different. size Fixed size points width lines, including outlines polygons. polygons, defaults 0, meaning outlines. points lines, defaults 0.5. Ignored size_by specified. shape Fixed shape points, ignored shape_by specified applicable. linetype Fixed line type, ignored linetype_by specified applicable. alpha Transparency. color Fixed color colGeometry color_by specified applicable, annotGeometry annot_color_by specified applicable. fill Similar color, fill. scattermore Logical, whether use scattermore package greatly speed plotting numerous points. used POINT colGeometries. geometry POINT, centroids used. Recommended plotting hundreds thousands cells cell polygons seen plotted due large number cells small plot size plotting multiple panels multiple features. pointsize Radius rasterized point scattermore. Default 0 single pixels (fastest). ... arguments passed wrap_plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dimension reduction components in space — spatialReducedDim","text":"plotSpatialFeature. ggplot2 object   plotting one component. patchwork object plotting multiple   components.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dimension reduction components in space — spatialReducedDim","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> snapshotDate(): 2022-10-24 #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- logNormCounts(sfe) sfe <- runPCA(sfe, ncomponents = 2) spatialReducedDim(sfe, \"PCA\", 2, \"spotPoly\",     annotGeometryName = \"tissueBoundary\",     divergent = TRUE, diverge_center = 0 )  # Basically PC1 separates spots not on tissue from those on tissue."},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"voyager-100","dir":"Changelog","previous_headings":"","what":"Voyager 1.0.0","title":"Voyager 1.0.0","text":"First version Bioconductor Univariate local global spatial statistics based spdep Plotting functions: gene expression metadata space, results local spatial analyses, plot dimension reductions space, plot correlograms Monte Carlo simulation results","code":""}]
